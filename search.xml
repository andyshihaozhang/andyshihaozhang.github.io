<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo+gitblog搭建记录</title>
      <link href="/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-git部署绑定域名"><a href="#1-git部署绑定域名" class="headerlink" title="1 - git部署绑定域名"></a>1 - git部署绑定域名</h2><p>转载：<a href="https://jacckx.me/2021/02/28/Hexo_Custom_Domain/">https://jacckx.me/2021/02/28/Hexo_Custom_Domain/</a></p><h2 id="2-butterfly魔改教程"><a href="#2-butterfly魔改教程" class="headerlink" title="2 - butterfly魔改教程"></a>2 - butterfly魔改教程</h2><p>转载：<a href="https://www.fomal.cc/posts/eec9786.html">https://www.fomal.cc/posts/eec9786.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IEEE488概述</title>
      <link href="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-IEEE488简介"><a href="#1-IEEE488简介" class="headerlink" title="1 - IEEE488简介"></a>1 - IEEE488简介</h2><p>​<strong>IEEE-488</strong> 是一种由<a href="https://zh.wikipedia.org/wiki/%E6%83%A0%E6%99%AE%E5%85%AC%E5%8F%B8">惠普公司</a>（现为<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E6%8D%B7%E5%80%AB%E7%A7%91%E6%8A%80">安捷伦科技</a>及<a href="https://zh.wikipedia.org/wiki/%E6%98%AF%E5%BE%B7%E7%A7%91%E6%8A%80">是德科技</a>）在1960年代开发的HP-IB（<em>Hewlett-Packard Interface Bus</em>，惠普接口总线）短程通信<a href="https://zh.wikipedia.org/wiki/%E6%80%BB%E7%BA%BF">总线</a>规范。随后成为了标准，并通称为<strong>GP-IB</strong>（<em>General Purpose Interface Bus</em>，通用接口总线）。</p><h2 id="2-GPIB总线构成"><a href="#2-GPIB总线构成" class="headerlink" title="2 - GPIB总线构成"></a>2 - GPIB总线构成</h2><h4 id="2-1-GPIB接口示例图"><a href="#2-1-GPIB接口示例图" class="headerlink" title="2.1 - GPIB接口示例图"></a>2.1 - GPIB接口示例图</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/IEEE_488_Connector.jpg" class title="IEEE_488_Connector"><h4 id="2-2-GPIB总线说明"><a href="#2-2-GPIB总线说明" class="headerlink" title="2.2 - GPIB总线说明"></a>2.2 - GPIB总线说明</h4><p><strong>Data Lines</strong></p><blockquote><p>The eight data lines, DIO1 through DIO8, carry both data and command messages. The state of the Attention (ATN) line determines whether the information is data or commands. All commands and most data use the 7-bit ASCII or ISO code set, in which case the eighth bit, DIO8, is either unused or used for parity.  </p></blockquote><p><strong>Handshake Lines</strong> </p><blockquote><p>Three lines asynchronously control the transfer of message bytes between devices. The process is called a 3-wire interlocked handshake. It guarantees that message bytes on the data lines are sent and received without transmission error. </p><p><strong>NRFD (not ready for data)</strong> - Indicates when a device is ready or not ready to receive a message byte. The line is driven by all devices when receiving commands, by Listeners when receiving data messages, and by the Talker when enabling the HS488 protocol.  </p><p><strong>NDAC (not data accepted)</strong> - Indicates when a device has or has not accepted a message byte. The line is driven by all devices when receiving commands, and by Listeners when receiving data messages.  </p><p><strong>DAV (data valid)</strong> - Tells when the signals on the data lines are stable (valid) and can beaccepted safely by devices. The Controller drives DAV when sending commands, and the Talker drives DAV when sending data messages.  </p></blockquote><p><strong>Interface Management Lines</strong> </p><blockquote><p>Five lines manage the flow of information across the interface: </p><p><strong>ATN (attention)</strong> - The Controller drives ATN true when it uses the data lines to send commands, and drives ATN false when a Talker can send data messages. </p><p><strong>IFC (interface clear)</strong> - The System Controller drives the IFC line to initialize the bus and become CIC.  </p><p><strong>REN (remote enable)</strong> - The System Controller drives the REN line, which is used to place devices in remote or local program mode.  </p><p><strong>SRQ (service request)</strong> - Any device can drive the SRQ line to asynchronously request service from the Controller.  </p><p><strong>EOI (end or identify)</strong> - The EOI line has two purposes - The Talker uses the EOI line to mark the end of a message string, and the Controller uses the EOI line to tell devices to identify their response in a parallel poll.</p></blockquote><h2 id="3-GPIB物理层"><a href="#3-GPIB物理层" class="headerlink" title="3 - GPIB物理层"></a>3 - GPIB物理层</h2><h4 id="3-1-Controllers-Talkers-and-Listeners"><a href="#3-1-Controllers-Talkers-and-Listeners" class="headerlink" title="3.1 - Controllers, Talkers, and Listeners"></a>3.1 - Controllers, Talkers, and Listeners</h4><blockquote><ul><li><strong>Controllers</strong> govern the flow of information on the bus by issuing Talker and Listener assignments to other devices on the bus. They respond to service requests from instruments, and they can pass control of the bus to other Controllers. There can be only one Controller-In-Charge (CIC or System Controller) per bus, which is responsible for overall management of the bus.</li><li><strong>Talkers</strong> place information on the data lines of the bus, but only when a Controller instructs them to do so. Only one device can talk at a time.</li><li><strong>Listeners</strong> retrieve information from the data lines of the bus, but only when a Controller instructs them to do so. Any number of devices can listen at the same time.</li></ul></blockquote><p><strong>注意：</strong></p><blockquote><p>Some devices are capable of playing more than one role. A digital voltmeter, for example, can be a Talker and a Listener. If your system has a National Instruments GPIB interface and software installed, it can function as a Talker, Listener, and Controller.</p></blockquote><h4 id="3-2-Command-Messages-vs-Data-Messages"><a href="#3-2-Command-Messages-vs-Data-Messages" class="headerlink" title="3.2 - Command Messages vs. Data Messages"></a>3.2 - Command Messages vs. Data Messages</h4><blockquote><p>GPIB Controllers use command messages to tell devices (instruments or other Controllers) when they can talk to provide information to the bus and when they can listen to information on the bus. The Talker and Listener assignments are sent as command messages, while the information is passed as data messages.</p><p>The major difference between a command message and a data message is the state of the Attention (ATN) line, which is one of the bus management lines. If the ATN line is asserted, any messages sent on the data lines are heard by all devices, and they are understood to be command messages. If the ATN line is not asserted, only the devices that were addressed to listen may receive the messages on the data lines.  </p></blockquote><h4 id="3-3-The-GPIB-Addressing-Protocol"><a href="#3-3-The-GPIB-Addressing-Protocol" class="headerlink" title="3.3 - The GPIB Addressing Protocol"></a>3.3 - The GPIB Addressing Protocol</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/GPIBAddressingProtocol.png" class width="1724139754287"><blockquote><p>Bits 0 through 4 indicate the primary address of the device, for which the Talker&#x2F;Listener assignment is intended. If bit 5 is high, the device should listen. If bit 6 is high, the device should talk. Bit 7 is a “don’t care” bit. Its value is ignored, so it is interpreted as a value of zero in command messages.</p><p>Each device on the bus must have a unique address. This address consists of a primary address (PAD) and a secondary address (SAD). As you can see from Figure 1, five of the data lines are used to indicate the GPIB primary address. This means that you could have a value from 0 to 31, for a total of 32 (2 to the power of 5) addresses; however, <strong>PAD 31 is never used as a primary address</strong>, because it is used for special command messages. This leaves a total of 31 possible primary addresses. The Controller-In-Charge (CIC) for a bus is almost always at PAD 0, so the instruments on a bus can have primary addresses from 1 to 30. A common mistake in working with the GPIB is assigning the same address to the controller board and the instrument, which will result in an EADR error (addressing error).</p><p>The GPIB secondary address is identical in its range of 0 to 30, which allows for a total of 961 (31 x 31) possible GPIB addresses, but the secondary address is very rarely used (the SAD is typically set to zero). Talker&#x2F;Listener assignments are part of the primary addressing information, so with PADs you use either bit 6 or bit 5 when you send a command message. This might prompt you to ask, “How do I send the SAD information?” For secondary addresses, you set both bits 6 and 5 high when you send a command message. If you need to communicate with a device that has a secondary address, you need to indicate its primary address first and then immediately indicate its secondary address.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Command codes</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNL  0x3f  <span class="comment">// GPIB unlisten command</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNT  0x5f  <span class="comment">// GPIB untalk command</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GTL  0x01  <span class="comment">// GPIB go to local</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDC  0x04  <span class="comment">// GPIB selected device clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPC  0x05  <span class="comment">// GPIB parallel poll configure</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET  0x08  <span class="comment">// GPIB group execute trigger</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCT  0x09  <span class="comment">// GPIB take control</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLO  0x11  <span class="comment">// GPIB local lock out</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCL  0x14  <span class="comment">// GPIB device clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPU  0x15  <span class="comment">// GPIB parallel poll unconfigure</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPE  0x18  <span class="comment">// GPIB serial poll enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPD  0x19  <span class="comment">// GPIB serial poll disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPE  0x60  <span class="comment">// GPIB parallel poll enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPD  0x70  <span class="comment">// GPIB parallel poll disable</span></span></span><br></pre></td></tr></table></figure><h4 id="3-4-Handshake"><a href="#3-4-Handshake" class="headerlink" title="3.4 - Handshake"></a>3.4 - Handshake</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/gpib%E6%8F%A1%E6%89%8B.png" class width="1724138669001"><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/HandShakeandManageMentLines.png" class width="1724142045673"><h4 id="3-5-Information-transfer"><a href="#3-5-Information-transfer" class="headerlink" title="3.5 - Information transfer"></a>3.5 - Information transfer</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/GPIB_MessageTransmision.png" class title="GPIB_MessageTransmision"><h2 id="4-GPIB驱动层（NI驱动）"><a href="#4-GPIB驱动层（NI驱动）" class="headerlink" title="4 - GPIB驱动层（NI驱动）"></a>4 - GPIB驱动层（NI驱动）</h2><h4 id="4-1-Status"><a href="#4-1-Status" class="headerlink" title="4.1 - Status"></a>4.1 - Status</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// GPIB status bit vector: global variable ibsta and wait mask</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR   (1&lt;&lt;15)  <span class="comment">// Error detected</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMO  (1&lt;&lt;14)  <span class="comment">// Timeout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END   (1&lt;&lt;13)  <span class="comment">// EOI or EOS detected</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRQI  (1&lt;&lt;12)  <span class="comment">// SRQ detected by CIC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQS   (1&lt;&lt;11)  <span class="comment">// Device needs service</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMPL  (1&lt;&lt;8)   <span class="comment">// I/O completed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOK   (1&lt;&lt;7)   <span class="comment">// Local lockout state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REM   (1&lt;&lt;6)   <span class="comment">// Remote state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIC   (1&lt;&lt;5)   <span class="comment">// Controller-in-Charge</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATN   (1&lt;&lt;4)   <span class="comment">// Attention asserted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACS  (1&lt;&lt;3)   <span class="comment">// Talker active</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LACS  (1&lt;&lt;2)   <span class="comment">// Listener active</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTAS  (1&lt;&lt;1)   <span class="comment">// Device trigger state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCAS  (1&lt;&lt;0)   <span class="comment">// Device clear state</span></span></span><br></pre></td></tr></table></figure><h4 id="4-2-Error"><a href="#4-2-Error" class="headerlink" title="4.2 - Error"></a>4.2 - Error</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Error messages returned in global variable iberr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDVR   0  <span class="comment">// System error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECIC   1  <span class="comment">// Function requires GPIB board to be CIC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOL   2  <span class="comment">// Write function detected no Listeners</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADR   3  <span class="comment">// Interface board not addressed correctly</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARG   4  <span class="comment">// Invalid argument to function call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESAC   5  <span class="comment">// Function requires GPIB board to be SAC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EABO   6  <span class="comment">// I/O operation aborted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEB   7  <span class="comment">// Non-existent interface board</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDMA   8  <span class="comment">// Error performing DMA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOIP  10  <span class="comment">// I/O operation started before previous operation completed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECAP  11  <span class="comment">// No capability for intended operation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFSO  12  <span class="comment">// File system operation error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUS  14  <span class="comment">// Command error during device call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTB  15  <span class="comment">// Serial poll status byte lost</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRQ  16  <span class="comment">// SRQ remains asserted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETAB  20  <span class="comment">// The return buffer is full</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELCK  21  <span class="comment">// Address or board is locked</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARM  22  <span class="comment">// The ibnotify Callback failed to rearm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHDL  23  <span class="comment">// The input handle is invalid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWIP  26  <span class="comment">// Wait already in progress on input ud</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERST  27  <span class="comment">// The event notification was cancelled due to a reset of the interface</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPWR  28  <span class="comment">// The system or board has lost power or gone to standby</span></span></span><br></pre></td></tr></table></figure><h4 id="4-3-EOS-EOI"><a href="#4-3-EOS-EOI" class="headerlink" title="4.3 - EOS&amp;EOI"></a>4.3 - EOS&amp;EOI</h4><blockquote><p>GPIB data transfers are terminated either when the GPIB EOI line is asserted with the last byte of a transfer or when a preconfigured end-of-string (EOS) character is transmitted. By default, EOI is asserted with the last byte of writes and the EOS modes are disabled.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// EOS mode bits</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN   (1&lt;&lt;12)  <span class="comment">// Eight bit compare</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XEOS  (1&lt;&lt;11)  <span class="comment">// Send END with EOS byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REOS  (1&lt;&lt;10)  <span class="comment">// Terminate read on EOS</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>EOS comparison method</strong>—This indicates whether the EOS byte  has seven or eight significant bits. For a 7-bit EOS byte, the eighth bit of the  EOS byte is ignored.  </li><li><strong>EOS write method</strong>—If this is enabled, the GPIB EOI line is  automatically asserted when the EOS byte is written to the GPIB. If the buffer  passed into an  ibwrt call contains five occurrences of  the EOS byte, the EOI line is asserted as each of the five EOS bytes are written  to the GPIB. If an ibwrt buffer does not contain an  occurrence of the EOS byte, the EOI line is not asserted (unless the EOT mode is  enabled, in which case the EOI line is asserted with the last byte of the  write).  </li><li><strong>EOS read method</strong>—If this is enabled, ibrd, ibrda, and ibrdf calls are terminated when the EOS byte is detected  on the GPIB, when the GPIB EOI line is asserted, or when the specified count is  reached. If the EOS read method is disabled, ibrd,  ibrda, and ibrdf calls  terminate only when the GPIB EOI line is asserted or the specified count has  been read.</li></ul></blockquote><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/EOI&EOS.png" class width="1724205780470"><h4 id="4-4-Timeout"><a href="#4-4-Timeout" class="headerlink" title="4.4 - Timeout"></a>4.4 - Timeout</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timeout values and meanings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TNONE    0   <span class="comment">// Infinite timeout (disabled)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10us    1   <span class="comment">// Timeout of 10 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30us    2   <span class="comment">// Timeout of 30 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100us   3   <span class="comment">// Timeout of 100 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300us   4   <span class="comment">// Timeout of 300 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1ms     5   <span class="comment">// Timeout of 1 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T3ms     6   <span class="comment">// Timeout of 3 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10ms    7   <span class="comment">// Timeout of 10 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30ms    8   <span class="comment">// Timeout of 30 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100ms   9   <span class="comment">// Timeout of 100 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300ms  10   <span class="comment">// Timeout of 300 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1s     11   <span class="comment">// Timeout of 1 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T3s     12   <span class="comment">// Timeout of 3 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10s    13   <span class="comment">// Timeout of 10 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30s    14   <span class="comment">// Timeout of 30 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100s   15   <span class="comment">// Timeout of 100 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300s   16   <span class="comment">// Timeout of 300 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1000s  17   <span class="comment">// Timeout of 1000 s (ideal)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>The timeout period is used to select the maximum duration allowed for a synchronous I&#x2F;O operation (for example, ibrd and ibwrt) or for an ibwait or ibnotify operation with TIMO in the wait mask. If the<br>operation does not complete before the timeout period elapses, the operation is aborted and TIMO is returned in Ibsta. The timeout values represent the minimum timeout period. The actual period could be longer</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统杂谈</title>
      <link href="/2024/08/14/computerMem/"/>
      <url>/2024/08/14/computerMem/</url>
      
        <content type="html"><![CDATA[<h2 id="一、存储系统总览"><a href="#一、存储系统总览" class="headerlink" title="一、存储系统总览"></a>一、存储系统总览</h2><img src="/2024/08/14/computerMem/computer_memflow.png" class title="存储系统流程图"><h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 - 概念"></a>1 - 概念</h3><p>​内存（主存）为计算机进行活动过程中用来存储活动数据的空间，比如计算的数据，执行的指令等</p><h3 id="2-内存构成"><a href="#2-内存构成" class="headerlink" title="2 - 内存构成"></a>2 - 内存构成</h3><p>​内存一般由DRAM芯片构成，DRAM芯片利用栅极电容存储信息，所以本质上存储的是电信号，同时栅极电容具有电容的特性，所以DRAM也存在刷新机制用于维护电信号。</p><p>​DRAM只是一个存储芯片，那么我们现在常说的内存条又是个什么鬼呢？</p><p>​一般来说，存储芯片所能容纳的数据量其实很有限，比如4K * 4bit（16 * 1024bit）数据量，</p><h3 id="3-内存地址"><a href="#3-内存地址" class="headerlink" title="3 - 内存地址"></a>3 - 内存地址</h3><p>​由上可知，内存存储的是电信号，本质上就是正负信号（0&#x2F;1），对应的就是bit位。在计算机系统中，通常使用字节作为单位用来存储8bit（1B &#x3D; 8b）的数据，当我们对每个字节进行编址就得到了整个内存的地址大小。内存地址也即<strong>物理地址</strong>，好比房间和房间号。</p><p>​研究一个问题：假设现在只有一个4GB的内存条，也就是物理内存只能访问到0x0000 ~0xFFFF地址大小，但是如果我的程序很大，比如占用了8个G（模型渲染、机器学习等），但是物理空间只有4GB大小，也就是说我8G的空间，只有4G的门牌号，剩余4G的空间系统里都查不到，这肯定是不合适的，但是我们可以很容易想到一个方法 — 拓展内存大小：</p><p>​我们给我们的主机加上内存条，拓展到8G大小这样不就行了吗？</p><p>​但是有两个缺点：1、贵</p><p>​       2、缓兵之计，要是下一次10G怎么办？</p><p>​有的人又会问，硬盘不贵，同等空间硬盘便宜多了，但是硬盘便宜的代价就是硬盘很慢，所以cpu不会直接同硬盘进行数据交互，cpu宝贵的资源超快的速度不可能每次都等待硬盘进行数据传输，所以我们需要的是一个机制—一个从根本上解决程序地址和物理地址不匹配的机制，那既然程序地址无法同物理地址一一对应，那么我们就可以将耦合解开来，采用别的方式完成程序地址到物理地址的转换，此处转换也即映射，此处程序地址就是我们要谈论的<strong>虚拟地址</strong>。</p><h3 id="4-内存数据获取方式"><a href="#4-内存数据获取方式" class="headerlink" title="4 - 内存数据获取方式"></a>4 - 内存数据获取方式</h3><p>​既然有了存放数据的空间，也知道这些空间的编号，那么我们获取数据的方式无非就是按照编号找到对应的空间，然后取出对应的数据。而编号就是我们的物理地址，找数据的过程就是对应选片读取的过程。</p><p>​如果现在编址空间为24bit表示大小，也就是0x000000~0xFFFFFF大小，如果我们将内存看作为一个矩阵空间（实际DRAM就是），每一行使用12bit容纳的空间，也就是每一行存储2^12（4096）B的数据，那么剩余12bit就成为了行号，此时我们就可称这24bit中，高12bit为行号，低12bit为列号，也称前者为行地址，后者为列地址。</p><p>​同时为了节省资源，现代计算机通常使用行列地址复用技术减少地址线的根数。那么此处实际上我们只需要12跟地址线就足以，当我们想要获取某一个单元的数据的时候，我们通常会选择先传送12bit的行地址进行行选通，再传送12bit列地址进行列选通从而完成寻址，随后将数据读出通过数据线传送到CPU中。</p><h2 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1 - 引言"></a>1 - 引言</h3><p>​我们知道，程序员写代码的时候不需要关心物理地址，访问都是通过指针或者索引或者其他形式去访问，既然底层是通过地址去获取存储单元中的数据，那么这一环节是如何转换的呢？</p><p>​以c为例，我们c代码是高级语言，代码执行过程可以有以下的执行过程：</p><img src="/2024/08/14/computerMem/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" class title="程序执行过程"><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span>  <span class="comment">// 预处理阶段处理</span></span></span><br><span class="line"></span><br><span class="line">代码段  <span class="comment">// 编译 -》 汇编 -》 链接 形成基于整个程序空间的逻辑地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ok，现在我们经过了预处理、编译、汇编、链接从而形成了可执行程序，并且整个可执行程序中的数据或者指令也都被我们进行了编址，也就是拥有了基于程序这个空间的地址，那么为什么要进行装入操作呢？直接将可执行程序上CPU运行不就完事了吗？</p><p>​其实，在以前的单道处理系统中是这样的，但是考虑效率现在的多道批处理系统中并非如此，现在的cpu是属于并发（甚至并行）执行多个程序，也就是说多个程序可能都要存储在内存中，那么小程序还行，如果是大程序怎么在有限的内存中进行操作呢？</p><h3 id="2-虚拟地址"><a href="#2-虚拟地址" class="headerlink" title="2 - 虚拟地址"></a>2 - 虚拟地址</h3><p>​上文说到我们需要采用一种机制，解决物理地址有限的问题，我们称之为虚拟地址（逻辑地址）。物理地址受限于物理引脚的个数，物理引脚的个数确定了物理上能访问的空间大小，而虚拟地址则受限于os系统的架构，例如32位x86架构能够访问的空间大小和64位的x64架构能访问的空间大小则完全不同。</p><p>​以32位x86架构的系统为例，我们虚拟地址以32bit进行编制，那么我们能够访问的空间的大小就是0x00000000 ~0xFFFFFFFF地址范围，我们说为什么受限呢？可以想想，我们现在写好了程序，编译、汇编、链接这些操作都是在哪里进行处理的？ 那必须是os中处理，所以我们被人家改造成了人家的位数，合情合理。</p><p>​ok，现在我们的访问地址变大了，在程序的角度能访问的所有的房间都有门牌号了，但是实际的存储范围其实就那么大，我们上文中提到的解决方式是将虚拟地址与逻辑地址之间一一对应的关系改造为虚拟地址到物理地址之间映射的关系从而达到扩大程序地址空间的目的，那么接下来详细谈谈这个映射机制，从<strong>虚拟内存</strong>开始说起。</p><h3 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3 - 虚拟内存"></a>3 - 虚拟内存</h3><p>​我们说，物理地址空间能访问的空间大小称之为物理内存。那么逻辑地址（虚拟地址）能访问的空间大小则称之为虚拟内存。</p><p>​接下来我们考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们之前谈到数据是以二进制存储在内存中，也就是数据是bit位；同时我们谈到内存中对数据编址是通过字节的形式，也就是B字节；</span><br><span class="line">​请问：我们程序运行过程中从内存中获取数据是以bit还是B为单位获取？</span><br><span class="line">​答案：我们地址是按照B为单位进行编址，自然我们也是以B位单位获取数据</span><br></pre></td></tr></table></figure><p>​再考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设现在有以下的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：我们需要将32bit的空间大小映射到24bit空间中，应该怎么做？</span><br><span class="line">​答案：使用一个表，记录下来逻辑地址到物理地址之间的对应关系，拿到逻辑地址的时候查表获取对应的物理地址从而获取对应的数据。</span><br></pre></td></tr></table></figure><h4 id="3-1-页表"><a href="#3-1-页表" class="headerlink" title="3.1 - 页表"></a>3.1 - 页表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，页表存放在内存中。</p><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">还是以上的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：现在有一个int类型的数据，请问怎么访问获取这个int类型的数据呢（不考虑大端小端等，只说明大致过程）？</span><br><span class="line">​答案：int类型的数据占用4个字节，也就是要获取连续的4个地址中保存的bit数据，所以我们需要根据将连续的4个逻辑地址通过查找页表来获取对应4个地址的物理地址，从而在物理内存中获取真实的物理数据。</span><br><span class="line"></span><br><span class="line">我们可以发现，再此过程中进行了4次地址转换，获得了4个物理地址，从而获取到了对应的4个B的数据。但是这个过程中存在一个问题，就是页表中也存在4条逻辑地址到物理地址的映射记录，ok，可能4条映射表现出来的问题不够明显，现在考虑我们想要获取如果是1MB的数据，那么映射记录就变成了1M个；如果是1GB数据，那么映射记录就变成了1G个；同时可以计算：</span><br><span class="line">逻辑地址32bit=4B，物理地址24bit=3B；</span><br><span class="line">那么</span><br><span class="line">        1M个记录 = 1M*7B = 7MB；</span><br><span class="line">        1G个记录 = 1G*7B = 7GB；</span><br><span class="line">        可以看出页表占用的内存大小是相当大的。</span><br><span class="line">所以我们需要规避这种空间损耗，那么就必须增大映射的单位大小，换句话说就是将原来以B为单位映射改为以一堆B为单位进行映射，所以页表是以页为单位进行映射的。</span><br><span class="line"></span><br><span class="line">现在我们重新以页的方式进行映射，假设页的大小为1KB，那么此时1MB个数据就缩减为了1K个记录！</span><br></pre></td></tr></table></figure><h4 id="3-2-段表"><a href="#3-2-段表" class="headerlink" title="3.2 - 段表"></a>3.2 - 段表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，段表存放在内存中。</p><p>​同上，我们还存在一种映射方式是以段为单位进行映射，也就是表中存储的是段的逻辑地址到物理地址之间的映射关系，我们将在下一小节中说明这些差别。</p><h4 id="3-3-页、段、页框"><a href="#3-3-页、段、页框" class="headerlink" title="3.3 - 页、段、页框"></a>3.3 - 页、段、页框</h4><p>​上文分析，为了避免不必要的浪费，我们引入了<strong>页</strong>这个概念，用来将一个B之间的映射转换为一堆B之间的映射；</p><p>​那么<strong>段</strong>存在的意义就是将一堆B之间的映射进一步提升为一个模块之间的映射。</p><p>​例如，现在有两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​那么在os层面，这两个模块照样会经过编译、汇编、链接成为二进制机器语言，那么为了保证函数的完整性，我们提出将func1作为一个段，将func2作为一个段。但是我们知道函数编译出来的产物通常是指令，而不是每个函数的指令长度都是一样的，也就是段的长度受实际代码复杂度等因素影响，所以在段表中我们是需要记录段的长度。</p><p>​在虚拟内存层面我们交换的单位称之为<strong>页</strong>或者<strong>段</strong>，那么物理内存层面我们与之对应的单位也有名字，成为<strong>页框</strong>。</p><h4 id="3-4-虚拟地址（以页为例）"><a href="#3-4-虚拟地址（以页为例）" class="headerlink" title="3.4 - 虚拟地址（以页为例）"></a>3.4 - 虚拟地址（以页为例）</h4><p>​在引入了页这个概念后，我们的逻辑（虚拟）地址就可以划分为以下的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址 = 逻辑地址剩余位数 + 页占用的位数</span><br><span class="line"></span><br><span class="line">同时，我们进一步将名称规范一下，逻辑地址剩余位数表示的其实就是对页进行编址，所以称之为页号，表示是第几个页；</span><br><span class="line">也占用的位数其实就是一个页中的第几个字节（因为毕竟总的来说是按照字节编址的），所以可以成为块内偏移；那么我们可以进一步写为:</span><br><span class="line"></span><br><span class="line">逻辑地址 = 页号 + 块内偏移地址</span><br></pre></td></tr></table></figure><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">依旧是上述的情景：</span><br><span class="line">逻辑地址32bit，物理地址24bit，页的大小为1KB</span><br><span class="line">逻辑地址 = 22bit页号 + 10bit页内偏移地址</span><br><span class="line">按照这个逻辑，我们需要记录22bit也就是4M个页的映射记录在页表中，也就是页表的大小为：</span><br><span class="line">4M * （22 +14）bit = 4M * 36bit = 18MB</span><br><span class="line">这是个不小的数字，同时伴随着地址空间的增大，这个数字还会增大，如果使用单级页表需要耗费巨大的连续空间，os对于这种空间的管理需要一定的消耗，而且考虑到并不是所有页都会被使用，所以还会造成大量的空间浪费。</span><br><span class="line">因此引入了多级页表的机制用于减少损耗，提高效率。假设现在使用的是两级页表，那么逻辑地址就可变成：</span><br><span class="line">逻辑地址 = 11bit一级页号 + 11bit二级页号 + 10bit块内（页内）偏移</span><br></pre></td></tr></table></figure><p>​ok，上文提到页表是存储在内存中的，同时我们的页号需要在页表中进行查找，那么我们怎么找到页表呢？</p><p>答案是–<strong>页表始址寄存器</strong></p><p>​页表始址寄存器会记录页表在内存中的起始地址，从而找到页表。页表始址寄存器中的值需要程序上cpu处理初始化上下文环境由进程PCB中获得初始化寄存器中的值。</p><p>​所以我们具体查找流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step4： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step5： 根据物理页框号找到内存中对应的页</span><br><span class="line">step6： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多级页表（二级为例）</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据一级页号和页表始址寄存器中页表起始地址去匹配获得二级页表地址</span><br><span class="line">step4： 根据二级页号在二级页表中匹配真正记录页号到页框号映射的页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：页表中并不需要逐个比对，由于顺序一致，所以</span></span><br><span class="line">页表项地址 = 页表基址 + 页表项大小 × 页号</span><br></pre></td></tr></table></figure><p>​ok，那现在我们可以从上述流程发现（单级页表为例），我们地址转换一共进行了两次访存（访问内存）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次：去内存查找页表获得物理地址</span><br><span class="line">第二次：去内存获取数据</span><br></pre></td></tr></table></figure><p>​同时我们知道，cpu和内存的效率差距很大，所以每一次访存都是一次很大的损耗，那么有没有办法能够提高效率呢？</p><p>​答案肯定是有的，现在计算机系统集成了一套机制–TLB机制，也称之为快表，相对应的就把内存中的页表称之为慢表。</p><h4 id="3-5-局部性原理"><a href="#3-5-局部性原理" class="headerlink" title="3.5 - 局部性原理"></a>3.5 - 局部性原理</h4><p>​谈论快表之前，谈论一下在计算机设计中广泛用到（包括下文的cache系统）的局部性原理；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">时间局部性（Temporal Locality）:</span><br><span class="line"></span><br><span class="line">时间局部性指的是程序在某一时刻访问了某个存储位置后，短时间内可能会再次访问该位置。例如，循环中的变量或频繁使用的子程序都有很高的时间局部性。</span><br><span class="line">例子: 在一个循环中，多次访问相同的变量或数组元素。每次循环迭代时，程序都会访问同一个存储位置。</span><br><span class="line"></span><br><span class="line">空间局部性（Spatial Locality）:</span><br><span class="line"></span><br><span class="line">空间局部性指的是程序在访问某个存储位置时，它附近的存储位置在不久的将来也可能会被访问。这意味着，如果一个存储位置被访问了，存储器中相邻的位置很可能也会被访问。</span><br><span class="line">例子: 在访问数组中的一个元素后，程序很可能会访问相邻的元素。</span><br></pre></td></tr></table></figure><h4 id="3-6-快表（TLB）"><a href="#3-6-快表（TLB）" class="headerlink" title="3.6 - 快表（TLB）"></a>3.6 - 快表（TLB）</h4><p>​快表其实本质上是一个页表的缓存，采用的是相联存储器（硬件），集成在CPU中，速度很快。映入快表后，查找流程就转变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号查找快表，若查找到对应物理页框号直接跳转step5</span><br><span class="line">step4： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br></pre></td></tr></table></figure><h4 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 - 小结"></a>3.7 - 小结</h4><p>​程序编译为可执行程序(二进制文件—ELF文件)；</p><p>​CPU调度进程上处理机运行，同时从PCB中获取信息初始化上下文（包括页表始址寄存器等);</p><p>​取指执行阶段，访存获取指令；</p><p>​查找快表；</p><p>​查找页表；</p><p>​访问内存；</p><p><strong>注意：</strong>这其中还包括查找不命中的情况，并非如此简单顺利，后续有时间再补充！</p><p>​至此，这一部分就完结了！</p><img src="/2024/08/14/computerMem/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" class title="逻辑地址映射关系"><h2 id="四、cache缓存"><a href="#四、cache缓存" class="headerlink" title="四、cache缓存"></a>四、cache缓存</h2><p>1 - 引言</p><p>​我们说物理内存是采用DRAM（动态随机存储器）构成，与CPU之间仍有效率差距，为了提高效率，同时践行局部性原理，引入内存的缓存机制-cache机制。</p><p>​cache采用SRAM（静态随机存储器）构成，比DRAM更快（同时也更贵）。</p><p>​cache作为内存的缓存，会保存部分内存的数据为了保证更快的访问，那么既然是保存部分数据，自然就涉及到以下的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 数据以什么形式保存在cache中</span><br><span class="line">2. 数据调入的方法</span><br><span class="line">3. 如何保证cache和主存数据的一致性</span><br><span class="line">4. 效率问题</span><br></pre></td></tr></table></figure><p>​下面将会对这些问题一一解答。</p><p>​同时上述的虚拟内存、逻辑地址体系完成了逻辑地址到物理地址的转换，现在我们终于拥有了物理地址，开始访问存储器……</p><h3 id="2-数据以什么形式保存在cache中"><a href="#2-数据以什么形式保存在cache中" class="headerlink" title="2 - 数据以什么形式保存在cache中"></a>2 - 数据以什么形式保存在cache中</h3><h3 id="3-数据调入的方法"><a href="#3-数据调入的方法" class="headerlink" title="3 - 数据调入的方法"></a>3 - 数据调入的方法</h3><h3 id="4-如何保证cache和主存数据的一致性"><a href="#4-如何保证cache和主存数据的一致性" class="headerlink" title="4 - 如何保证cache和主存数据的一致性"></a>4 - 如何保证cache和主存数据的一致性</h3><h3 id="5-效率问题"><a href="#5-效率问题" class="headerlink" title="5 - 效率问题"></a>5 - 效率问题</h3><h2 id="五、磁盘"><a href="#五、磁盘" class="headerlink" title="五、磁盘"></a>五、磁盘</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/13/hello-world/"/>
      <url>/2024/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
