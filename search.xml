<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>金融市场学入门知识</title>
      <link href="/2024/09/03/%E9%87%91%E8%9E%8D%E5%B8%82%E5%9C%BA%E5%AD%A6%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/03/%E9%87%91%E8%9E%8D%E5%B8%82%E5%9C%BA%E5%AD%A6%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[转载]: <a href="http://blog.fens.me/finance-market-intro/">http://blog.fens.me/finance-market-intro/</a>“金融市场学入门知识”</p><hr><h1 id="金融市场学入门知识"><a href="#金融市场学入门知识" class="headerlink" title="金融市场学入门知识"></a>金融市场学入门知识</h1><p><a href="http://blog.fens.me/series-it-finance/">用IT技术玩金融系列文章</a>，将介绍如何使用IT技术，处理金融大数据。在互联网混迹多年，已经熟练掌握一些IT技术。单纯地在互联网做开发，总觉得使劲的方式不对。要想靠技术养活自己，就要把技术变现。通过“跨界”可以寻找新的机会，创造技术的壁垒。</p><p>金融是离钱最近的市场，也是变现的好渠道！今天就开始踏上“用IT技术玩金融”之旅！</p><h4 id="关于作者："><a href="#关于作者：" class="headerlink" title="关于作者："></a>关于作者：</h4><ul><li>张丹(Conan), 程序员Java,R,PHP,Javascript</li><li>weibo：@Conan_Z</li><li>blog: <a href="http://blog.fens.me/">http://blog.fens.me</a></li><li>email: <a href="mailto:&#x62;&#x73;&#x73;&#112;&#105;&#x72;&#x69;&#x74;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;">&#x62;&#x73;&#x73;&#112;&#105;&#x72;&#x69;&#x74;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;</a></li></ul><h4 id="转载请注明出处：http-blog-fens-me-finance-market-intro"><a href="#转载请注明出处：http-blog-fens-me-finance-market-intro" class="headerlink" title="转载请注明出处：http://blog.fens.me/finance-market-intro/"></a>转载请注明出处：<a href="http://blog.fens.me/finance-market-intro/">http://blog.fens.me/finance-market-intro/</a></h4><p><img src="http://blog.fens.me/wp-content/uploads/2014/03/finance-market-intro.png" alt="金融市场学入门知识"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>金融市场是金融交易的场所，了解金融市场有助力让我们使用各种金融工具进行投资组合，实现对不同金融产品的资产配置，平衡投资收益和风险。</p><p>注：本人金融入门级，如果文章描述不对或者不准确的地方，还请专家指点。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ol><li>金融市场学基础知识体系结构</li><li>名词解释</li><li>计算举例</li></ol><h2 id="1-金融市场学基础知识体系结构"><a href="#1-金融市场学基础知识体系结构" class="headerlink" title="1. 金融市场学基础知识体系结构"></a>1. 金融市场学基础知识体系结构</h2><p><img src="http://blog.fens.me/wp-content/uploads/2014/03/finance-market.png"></p><h2 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2. 名词解释"></a>2. 名词解释</h2><ul><li>金融市场</li><li>金融市场工具</li><li>货币市场</li><li>债券市场</li><li>久期和凸性</li><li>股票市场</li><li>基金市场</li><li>外汇市场</li><li>金融衍生品市场</li><li>资本资产定价模型</li><li>套利定价理论</li></ul><h3 id="金融市场"><a href="#金融市场" class="headerlink" title="金融市场"></a>金融市场</h3><p>金融市场(Financial Market)，指以金融资产为交易对象而形成的供求关系及其他机制的总和。</p><p>包括3个层面：</p><ul><li>金融资产一个有形和无形的场所。</li><li>反映了金融资产的供应者和需求者之间的供求关系。</li><li>包含了金融资产交易过程中所产生的各种运行机制。</li></ul><p>金融中介(Financial Intermediaries)，是介于实质经济运行中资金供需双方之间的媒介。通过购买赤字单位发行的直接证券，然后再向盈余单位发行间接证券，成为赤字单位和盈余单位之间的媒介。</p><p>资本市场，是长期金融资金市场，是指融资期限在一年以上的中长期资金市场。</p><p>现货市场(Spot Market)，在交易协议达成的若干个交易日内交割的金融交易市场。</p><p>期货市场(Futures Market)，在交易协议达成，交易还要在某一特定时间进行的市场。</p><p>衍生品市场(Derivatives Market)，指由原生性金融商品或者基础性金融工具出的新型金融工具，包括远期合约，期货合约，期权合约，互换等。</p><p>发行市场，又称一级市场(Primary Market)，是指资金需求者奖金融资产首次出售给资金供给者时形成的交易市场。</p><p>流通市场，又称二级市场(Secondary Market)，是指金融工具发行后在投资者之间买卖，转让所形成的市场。</p><h3 id="金融市场工具"><a href="#金融市场工具" class="headerlink" title="金融市场工具"></a>金融市场工具</h3><p>如果把金融市场分为货币和资本市场两大类，那么金融市场工具也被为分这两大类。</p><p>货币市场工具：通常都是固定收益的，包括国库券，存单，商业票据，银行承兑汇票，欧洲美元，回购和逆回购，联邦基金，经纪人通知贷款。</p><p>资本市场工具：</p><ul><li>固定收益类：国库债券和票据，联邦机构债务，市政债券，公司债券，抵押支付证券</li><li>权益类：普通股，优先股</li><li>衍生品类：期权和互换，远期和期货</li></ul><p>资产证券化(Asset Securitization)是把流动性较差的资产通过商业银行或者投资银行的集中组合，作为抵押来发行证券，从而实现相关债权的流动化。</p><h3 id="货币市场"><a href="#货币市场" class="headerlink" title="货币市场"></a>货币市场</h3><p>货币市场(Monetary Market)，是短期金融资金市场，是指以期限在一年(以下)的金融资产为交易标的的市场。</p><p>同业拆借市场，是金融机构之间以货币借贷方式进行短期资金融通的主要场所。同业拆借交易是无担保的，是资金和信用的直接交换。</p><p>短期国库券市场，指短期国库券发行和交易的场所。国库券((Treasury Bills,T-bills)又有“金边证券”之称。</p><p>商业票据(Commercial Paper, CP)市场，指在商品交易和资金往来过程中产生的以汇票、本票和支票的发行、担保、承兑、贴现、转贴现来实现短期资金融通的市场。</p><p>大额可转让定期存单(Negotiable Certificates Of Deposits, CDs)，是银行发行的有固定面额、可转让流通的存款凭证，是定期存款证券化、市场化的产物，也是西方国家商业银行逃避存款利率管制、防止存款转移和提高存款竞争力的产物。</p><p>银行承兑汇票市场是，指以银行汇票为金融工具，通过汇票的发行、承兑、转让及贴现而实现资金融通的市场，是银行信用为基础的市场。银行承兑汇票(Banker’s Acceptance, BA)是指出票人开立的远期汇票，以银行为付款人，命令其在未来的某一确定时刻支付一定金额给收款人。</p><p>回购协议市场，指通过回购协议进行短期资金融通交易的场所。回购协议(Repurchase Agreement, Repo)是指某一交易商在卖出某一证券的同时约定未来某一时日再以事先确定的价格买回的交易；它的反向交易称为逆回购(Reverse Repurchase Agreement)。证券回购实质上是一种以证券为抵押品的短期资金融通方式，购买和回购价格之间的差额所隐含的收益率就是回购协议率(Repo Rate)。</p><p>利率关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">国库券利率 &lt; 回购协议利率 &lt; 银行承兑汇票利率 &lt; 可转让定期存单利率 &lt; 同业拆借利率</span><br></pre></td></tr></table></figure><p>联邦基金市场，指在美国联邦储备银行体系中开有准备金账户并缴存准备金的金融机构之间就准备金调剂所形成的交易市场。联邦基金(Fedreal Funds)，又称联邦储备金。</p><p>欧洲货币市场，指非居民之间以银行为中介在某种货币发行国国境之外从事某种货币借贷业务的市场，又称离岸(Offshore)市场。允许非居民相互之间融通外币资金。</p><h3 id="债券市场"><a href="#债券市场" class="headerlink" title="债券市场"></a>债券市场</h3><p>债券是一种基本的固定收益证券，全球金融市场中80%的直接融资是依靠各类债券市场来实现的。债券是指债券发行人为筹措资金，依照法定程序发行，向投资者出具的，承诺按标面标明的面额、利率、偿还期等支付利息并到期偿还本金的有价证券。</p><p>债券的5个要素：票面价值，偿还期限和方式，票面利率，付息方式，发行名称。</p><p>短期国债(Treasury Bills)偿还期限在1年(以内)的国债。中期国债(Tresury Notes)偿还期限在1-10年的国债。长期国债(Treasury Bonds)偿还期限在10年以上的国债。</p><p>净现值法(Net Present Value)，指批判的内在价值(V)与债券价格(P)的差额。</p><p>公式：NPV &#x3D; V - P</p><ul><li>如果NPV &gt; 0，则内在价值大于投资成本，债券被低估，应该购买。</li><li>如果NPM &lt; 0, 则内在价值小于投资成本，债券被高估，应该卖出。</li></ul><p>到期收益率(Yield to Maturity) 是使债券未来现金流量的现值等于债券价格的收益率，即投资净现值为零的贴现率。</p><p>公式： NPV &#x3D; V-P &#x3D; sum(C&#x2F;(1+k)^t)+A&#x2F;(1+k)^n - P &#x3D; 0，t &#x3D; 1,2,3,n，k为到期收益率。</p><p>假设c为一般市场利率，用k和c进行比较。</p><ul><li>如果k &gt; c，则债券被低估，购买债券。</li><li>如果k &lt; c，则债券被高估，卖出债券。</li></ul><h3 id="久期和凸性"><a href="#久期和凸性" class="headerlink" title="久期和凸性"></a>久期和凸性</h3><p>久期(Duration)，又称麦考莱久期，是考虑了所有债券产生的现金流的现值因素后测算的债券的实际到期日。久期定义为债券支付的加权到期日，每一次支付的权重为该次支付现金流现值的一定比例。</p><p>如果市场利率是Y，现金流（X1,X2,…,Xn）的麦考雷久期定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D(Y)=[1*X1/(1+Y)^1+2*X2/(1+Y)^2+...+n*Xn/(1+Y)^n]/[X0+x1/(1+Y)^1+X2/(1+Y)^2+...+Xn/(1+Y)^n]</span><br><span class="line"></span><br><span class="line">即 D=(1*PVx1+...n*PVxn)/PVx</span><br></pre></td></tr></table></figure><p>其中，PVXi表示第i期现金流的现值，D表示久期。</p><p>浅显易懂的解释：久期就是债券价格相对于利率水平正常变动的敏感度。如果一只短期债券基金的投资组合久期是2.0，那么利率每变化1个百分点，该基金价格将上升或下降2%；一只长期债券型基金的投资组合久期是12.0，那么利率每变化1个百分点，其价格将上升或下降12%。</p><p>久期定理：</p><ul><li>定理一：只有贴现债券的马考勒久期等于它们的到期时间。</li><li>定理二：直接债券的马考勒久期小于或等于它们的到期时间。</li><li>定理三：统一公债的马考勒久期等于（1+1&#x2F;y），其中y是计算现值采用的贴现率。</li><li>定理四：在到期时间相同的条件下，息票率越高，久期越短。</li><li>定理五：在息票率不变的条件下，到期时间越久，久期一般也越长。</li><li>定理六：在其他条件不变的情况下，债券的到期收益率越低，久期越长。</li></ul><p>凸性(Convexity)不仅描述了债券价格与债券收益率的反比关系，还具体指出了债券价格相对于收益率变化的变化幅度，收对于期限既定的债券，由收益率下降导致的债券价格上升的幅度大于同等幅度的收益上升导致的债券价格下降的幅度。</p><p>公式 ：dp&#x2F;p &#x3D; -D * dy + C(dy)^2&#x2F;2</p><p>凸性是债券价格对收益率的二阶导数。</p><ul><li>凸性随久期的增加而增加。若收益率、久期不变，票面利率越大，凸性越大。利率下降时，凸性增加。</li><li>对于没有隐含期权的债券来说，凸性总大于0，即利率下降，债券价格将以加速度上升;当利率上升时，债券价格以减速度下降。</li><li>含有隐含期权的债券的凸性一般为负，即价格随着利率的下降以减速度上升，或债券的有效持续期随利率的下降而缩短，随利率的上升而延长。因为利率下降时买入期权的可能性增加了。</li></ul><p>凸性是对债券价格利率敏感性的二阶估计，是对债券久期利率敏感性的测量。在价格－收益率出现大幅度变动时，它们的波动幅度呈非线性关系。由持久期作出的预测将有所偏离。凸性就是对这个偏离的修正。</p><h3 id="股票市场"><a href="#股票市场" class="headerlink" title="股票市场"></a>股票市场</h3><p>普通股(Common Stock)是在优先股要求权得到满足后才能与公司利润和资产分配的股，其股息收益不确定，随公司的利润分配政策的变动而变动。</p><p>优先股(Preferred Stock)指在剩余索取权方面较普通股优先的股票，体现在伊利固定数额的股息，并可以先于普通股股东收取股息，但持有者无经营管理权，也不参与公司决策。</p><p>A股：以人民币标明面值，由境内公司在中国境内发行上市，境内居民或机构用人民币买卖的股票。</p><p>B股：用人民币标明面值，由境内公司在地内发行，在境内证券交易所上市，由境内外居民或机构用外币买卖的股票。</p><p>H股，N股，S股：属于境外上市的外资股，用人民币标明面值，由境内公司发行，分别在香港，纽约，新加坡上市，分别用港币交易，美元，新加坡元交易。</p><p>股票发行市场(Issuance Market)又叫一级市场(Primary Market)，是股票的发行者按照一定的法律规定和发行程序，直接或通过中介机构向投资者出售新股所形成的市场。</p><p>股票交易市场，又叫二级市场(Secondary Market)是投资都之间买卖已发行股票的场所。</p><p>场外交易，又叫柜台交易(Over-The-Counter, OTC)，在证券交易所之外的股票交易活动，这种交易最早在券商的柜台上进行。</p><p>市盈率又称价格收益比，是每股价格与每投收益的比率。</p><p>公式： 市盈率 &#x3D; 每股价格 &#x2F; 每股收益</p><h3 id="基金市场"><a href="#基金市场" class="headerlink" title="基金市场"></a>基金市场</h3><p>封闭式基金，指基金的发起人在设立基金时，限定了基金单位的发行总额，筹集到这个总额后，基金即宣告成立，并进行封闭，在一定时期内不再接受新的投资，又称固定型投资基金。</p><p>开放式基金，指基金管理公司在设立基金时，发行基金单位的总份额不固定，可视投资者的需求追加发行。</p><p>基金计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基金资产总额 = 所持证券市值总额 + 现金 + 应计利息收入</span><br><span class="line">基金资产净值总额 = 基金资产总额 - 基金负债总额</span><br><span class="line">基金单位净值 = 基金资产净值总额 / 总份额</span><br><span class="line"></span><br><span class="line">申购价 = 基金单位资产净值 + 申购费用</span><br><span class="line">申购费用 = 申购价 * 申购费率</span><br><span class="line"></span><br><span class="line">赎回价 = 基金单位资产净值 + 赎回费用*(1-折扣率)</span><br></pre></td></tr></table></figure><p>更详细的基金计算，请参考文章：<a href="http://blog.fens.me/finance-fund-accounting/">基金会计系统 – 组合净值,单位净值,份额</a></p><p>外汇市场</p><p>关于外汇市场的概念，请参考文章：<a href="http://blog.fens.me/finance-international-intro/">国际金融入门知识</a></p><h3 id="金融衍生品市场"><a href="#金融衍生品市场" class="headerlink" title="金融衍生品市场"></a>金融衍生品市场</h3><p>金融远期合约，指交易双方约定在未来某一交易日，按照事先约定的价格，以预先确定的方式买卖一定数量的某种金融资产的合约。</p><p>远期利率协议(Forward Rate Agreement, FRA)是交易双方商定在未来某一时间对某一具体期限的名义上的存款或者贷款支付利率的合同，并规定期满时，由一方向另一方支付协议利率与结算日参考利率之间的贴现后的利息差。</p><p>远期外汇，又称期汇交易，指在外汇买卖成效晨，交易双方先签订合同，规定买卖外汇的币种，数量，适用的汇率及未来交割的日期，地点等，并在规定的交割日期按照合同规定进行交割的外汇业务。</p><p>金融期货合约，指协议双方约定在未来某一特定的时间按约定条件(价格，交割地点，交割方式)买卖一定标准数量的某种特定金融产品的标准化协议。</p><p>外汇期货，指交易双方约定在未来特定的日期进行外汇交割，限定了标准币种，数量，交割月份及交割地点的标准化合约。</p><p>利率期货，指标的资产价格全副于利率水平的期货合约。</p><p>股指期货，指期货交易所同期货买卖都签订的，约定在未来某时期，买者向交易所结算等于股份指数若干倍金额的合约。</p><p>金融期权，指赋予购买者在规定的期限内按双方约定的价格买卖一定数量某种金融资产的权利的合约。包括股票指数期权，股票期权，利率期权，期货期权。</p><p>金融互换，指买卖双方在一定时间内，交换一系列现金流的合约。包括货币互换，利率互换。</p><h3 id="资本资产定价模型"><a href="#资本资产定价模型" class="headerlink" title="资本资产定价模型"></a>资本资产定价模型</h3><p>无差异曲线，代表给一个投资者带来同样满足程序的风险和预期收益率的所有组合。</p><p>资本资产定价模型(Capital Asset Pricing Model, CAPM)，在投资组合理论和资本市场理论基础上形成发展起来的，主要研究证券市场中资产的预期收益率与风险资产之间的关系，以及均衡价格是如何形成的.</p><p>CAPM给出了一个非常简单的结论：只有一种原因会使投资者得到更高回报，那就是投资高风险的股票。</p><p>CAPM是建立在马科威茨模型基础上的，马科威茨模型的假设自然包含在其中：</p><ul><li>1、投资者希望财富越多愈好，效用是财富的函数，财富又是投资收益率的函数，因此可以认为效用为收益率的函数。</li><li>2、投资者能事先知道投资收益率的概率分布为正态分布。</li><li>3、投资风险用投资收益率的方差或标准差标识。</li><li>4、影响投资决策的主要因素为期望收益率和风险两项。</li><li>5、投资者都遵守主宰原则（Dominance rule），即同一风险水平下，选择收益率较高的证券；同一收益率水平下，选择风险较低的证券。</li></ul><p>CAPM的附加假设条件：</p><ul><li>6、可以在无风险折现率R的水平下无限制地借入或贷出资金。</li><li>7、所有投资者对证券收益率概率分布的看法一致，因此市场上的效率边界只有一条。</li><li>8、所有投资者具有相同的投资期限，而且只有一期。</li><li>9、所有的证券投资可以无限制的细分，在任何一个投资组合里可以含有非整数股份。</li><li>10、税收和交易费用可以忽略不计。</li><li>11、所有投资者可以及时免费获得充分的市场信息。</li><li>12、不存在通货膨胀，且折现率不变。</li><li>13、投资者具有相同预期，即他们对预期收益率、标准差和证券之间的协方差具有相同的预期值。</li></ul><p>上述假设表明：第一，投资者是理性的，而且严格按照马科威茨模型的规则进行多样化的投资，并将从有效边界的某处选择投资组合；第二，资本市场是完全有效的市场，没有任何磨擦阻碍投资。</p><h3 id="套利定价理论"><a href="#套利定价理论" class="headerlink" title="套利定价理论"></a>套利定价理论</h3><p>套利定价理论(Arbitrage Pricing Theory, APT) 是CAPM的拓广，由APT给出的定价模型与CAPM一样，都是均衡状态下的模型，不同的是APT的基础是因素模型。</p><p>套利定价理论认为，套利行为是现代有效率市场（即市场均衡价格）形成的一个决定因素。如果市场未达到均衡状态的话，市场上就会存在无风险套利机会。 并且用多个因素来解释风险资产收益，并根据无套利原则，得到风险资产均衡收益与多个因素之间存在（近似的）线性关系。 而前面的CAPM模型预测所有证券的收益率都与唯一的公共因子（市场证券组合）的收益率存在着线性关系。</p><h2 id="3-计算举例"><a href="#3-计算举例" class="headerlink" title="3. 计算举例"></a>3. 计算举例</h2><h3 id="3-1-债券估值方法：净现值法"><a href="#3-1-债券估值方法：净现值法" class="headerlink" title="3.1 债券估值方法：净现值法"></a>3.1 债券估值方法：净现值法</h3><p>某一付息债券的面值为1000元，期限为2年，票面利率为5%， 每年付息，若市场利率为15%，当前该债券的市场价格为900元，是否应购买？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内在价值V = sum((1000*5%)/(1+0.15)^t) + 1000/(1+0.15)^2 = 837.43 ，t=1,2</span><br><span class="line"></span><br><span class="line">NPV = V - P = 837.43 - 900 = -62.57 &lt; 0</span><br></pre></td></tr></table></figure><p>则债券被高估了，不应该购买。</p><h3 id="3-2-债券估值方法：到期收益率比较法"><a href="#3-2-债券估值方法：到期收益率比较法" class="headerlink" title="3.2 债券估值方法：到期收益率比较法"></a>3.2 债券估值方法：到期收益率比较法</h3><p>某债券面值1000元，债券期限为3年，票面利率为6%， 每年付息一次，若投资者的必要收益率为9%，现行价格900元，是否应该购买？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">900 = sum((1000*6%)/(1+k)^t) + 1000/(1+k)^3， t=1,2,3</span><br><span class="line"></span><br><span class="line">解：k = 10.02% &gt; 9%</span><br></pre></td></tr></table></figure><p>则债券被低估了，应该购买。</p><h3 id="3-3-久期"><a href="#3-3-久期" class="headerlink" title="3.3 久期"></a>3.3 久期</h3><p>期限为5年，票面价值为1000元的零息债券，市场价格为750元，如果预期市场利率将由5%下降至4.5%，则此时该债券的市场价格是多少？</p><p>解：由于债券为零息债券，久期是它的到期期限，即5年。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dr/(1+r) = (5 * 5%)/(1+5%)=0.2381，</span><br><span class="line">而债券的市场利率下降比率为：(5%-4.5%)/5%=10%， </span><br><span class="line">所以债券的市场价格上升2.381%</span><br><span class="line">债券价格可能会变为：750*(1*2.381%)=767.86</span><br></pre></td></tr></table></figure><h4 id="转载请注明出处：http-blog-fens-me-finance-market-intro-1"><a href="#转载请注明出处：http-blog-fens-me-finance-market-intro-1" class="headerlink" title="转载请注明出处：http://blog.fens.me/finance-market-intro/"></a>转载请注明出处：<a href="http://blog.fens.me/finance-market-intro/">http://blog.fens.me/finance-market-intro/</a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> 金融基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/03/hello-world/"/>
      <url>/2024/09/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+gitblog搭建记录</title>
      <link href="/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-git部署绑定域名"><a href="#1-git部署绑定域名" class="headerlink" title="1 - git部署绑定域名"></a>1 - git部署绑定域名</h2><p>转载：<a href="https://jacckx.me/2021/02/28/Hexo_Custom_Domain/">https://jacckx.me/2021/02/28/Hexo_Custom_Domain/</a></p><h2 id="2-butterfly魔改教程"><a href="#2-butterfly魔改教程" class="headerlink" title="2 - butterfly魔改教程"></a>2 - butterfly魔改教程</h2><p>转载：<a href="https://www.fomal.cc/posts/eec9786.html">https://www.fomal.cc/posts/eec9786.html</a></p><h2 id="3-hexo博客迁移"><a href="#3-hexo博客迁移" class="headerlink" title="3 - hexo博客迁移"></a>3 - hexo博客迁移</h2><p>当前方案转载：<a href="https://blog.csdn.net/K1052176873/article/details/122879462">https://blog.csdn.net/K1052176873/article/details/122879462</a></p><p>完美方案转载：<a href="https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html">https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html</a></p><h2 id="4-hexo新环境安装失败"><a href="#4-hexo新环境安装失败" class="headerlink" title="4 - hexo新环境安装失败"></a>4 - hexo新环境安装失败</h2><p>清除原代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy null</span><br><span class="line">npm config set https-proxy null</span><br></pre></td></tr></table></figure><p>查看代理是否为null</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get proxy</span><br><span class="line">npm config get https-proxy</span><br></pre></td></tr></table></figure><p>安装cnpm环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>若出现如下图状态</p><p><img src="/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%5Cimage-20240903100028185.png" alt="image-20240903100028185"></p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IEEE488概述</title>
      <link href="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-IEEE488简介"><a href="#1-IEEE488简介" class="headerlink" title="1 - IEEE488简介"></a>1 - IEEE488简介</h2><p>​<strong>IEEE-488</strong> 是一种由<a href="https://zh.wikipedia.org/wiki/%E6%83%A0%E6%99%AE%E5%85%AC%E5%8F%B8">惠普公司</a>（现为<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E6%8D%B7%E5%80%AB%E7%A7%91%E6%8A%80">安捷伦科技</a>及<a href="https://zh.wikipedia.org/wiki/%E6%98%AF%E5%BE%B7%E7%A7%91%E6%8A%80">是德科技</a>）在1960年代开发的HP-IB（<em>Hewlett-Packard Interface Bus</em>，惠普接口总线）短程通信<a href="https://zh.wikipedia.org/wiki/%E6%80%BB%E7%BA%BF">总线</a>规范。随后成为了标准，并通称为<strong>GP-IB</strong>（<em>General Purpose Interface Bus</em>，通用接口总线）。</p><h2 id="2-GPIB总线构成"><a href="#2-GPIB总线构成" class="headerlink" title="2 - GPIB总线构成"></a>2 - GPIB总线构成</h2><h4 id="2-1-GPIB接口示例图"><a href="#2-1-GPIB接口示例图" class="headerlink" title="2.1 - GPIB接口示例图"></a>2.1 - GPIB接口示例图</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/IEEE_488_Connector.jpg" class title="IEEE_488_Connector"><h4 id="2-2-GPIB总线说明"><a href="#2-2-GPIB总线说明" class="headerlink" title="2.2 - GPIB总线说明"></a>2.2 - GPIB总线说明</h4><p><strong>Data Lines</strong></p><blockquote><p>The eight data lines, DIO1 through DIO8, carry both data and command messages. The state of the Attention (ATN) line determines whether the information is data or commands. All commands and most data use the 7-bit ASCII or ISO code set, in which case the eighth bit, DIO8, is either unused or used for parity.  </p></blockquote><p><strong>Handshake Lines</strong> </p><blockquote><p>Three lines asynchronously control the transfer of message bytes between devices. The process is called a 3-wire interlocked handshake. It guarantees that message bytes on the data lines are sent and received without transmission error. </p><p><strong>NRFD (not ready for data)</strong> - Indicates when a device is ready or not ready to receive a message byte. The line is driven by all devices when receiving commands, by Listeners when receiving data messages, and by the Talker when enabling the HS488 protocol.  </p><p><strong>NDAC (not data accepted)</strong> - Indicates when a device has or has not accepted a message byte. The line is driven by all devices when receiving commands, and by Listeners when receiving data messages.  </p><p><strong>DAV (data valid)</strong> - Tells when the signals on the data lines are stable (valid) and can beaccepted safely by devices. The Controller drives DAV when sending commands, and the Talker drives DAV when sending data messages.  </p></blockquote><p><strong>Interface Management Lines</strong> </p><blockquote><p>Five lines manage the flow of information across the interface: </p><p><strong>ATN (attention)</strong> - The Controller drives ATN true when it uses the data lines to send commands, and drives ATN false when a Talker can send data messages. </p><p><strong>IFC (interface clear)</strong> - The System Controller drives the IFC line to initialize the bus and become CIC.  </p><p><strong>REN (remote enable)</strong> - The System Controller drives the REN line, which is used to place devices in remote or local program mode.  </p><p><strong>SRQ (service request)</strong> - Any device can drive the SRQ line to asynchronously request service from the Controller.  </p><p><strong>EOI (end or identify)</strong> - The EOI line has two purposes - The Talker uses the EOI line to mark the end of a message string, and the Controller uses the EOI line to tell devices to identify their response in a parallel poll.</p></blockquote><h2 id="3-GPIB物理层"><a href="#3-GPIB物理层" class="headerlink" title="3 - GPIB物理层"></a>3 - GPIB物理层</h2><h4 id="3-1-Controllers-Talkers-and-Listeners"><a href="#3-1-Controllers-Talkers-and-Listeners" class="headerlink" title="3.1 - Controllers, Talkers, and Listeners"></a>3.1 - Controllers, Talkers, and Listeners</h4><blockquote><ul><li><strong>Controllers</strong> govern the flow of information on the bus by issuing Talker and Listener assignments to other devices on the bus. They respond to service requests from instruments, and they can pass control of the bus to other Controllers. There can be only one Controller-In-Charge (CIC or System Controller) per bus, which is responsible for overall management of the bus.</li><li><strong>Talkers</strong> place information on the data lines of the bus, but only when a Controller instructs them to do so. Only one device can talk at a time.</li><li><strong>Listeners</strong> retrieve information from the data lines of the bus, but only when a Controller instructs them to do so. Any number of devices can listen at the same time.</li></ul></blockquote><p><strong>注意：</strong></p><blockquote><p>Some devices are capable of playing more than one role. A digital voltmeter, for example, can be a Talker and a Listener. If your system has a National Instruments GPIB interface and software installed, it can function as a Talker, Listener, and Controller.</p></blockquote><h4 id="3-2-Command-Messages-vs-Data-Messages"><a href="#3-2-Command-Messages-vs-Data-Messages" class="headerlink" title="3.2 - Command Messages vs. Data Messages"></a>3.2 - Command Messages vs. Data Messages</h4><blockquote><p>GPIB Controllers use command messages to tell devices (instruments or other Controllers) when they can talk to provide information to the bus and when they can listen to information on the bus. The Talker and Listener assignments are sent as command messages, while the information is passed as data messages.</p><p>The major difference between a command message and a data message is the state of the Attention (ATN) line, which is one of the bus management lines. If the ATN line is asserted, any messages sent on the data lines are heard by all devices, and they are understood to be command messages. If the ATN line is not asserted, only the devices that were addressed to listen may receive the messages on the data lines.  </p></blockquote><h4 id="3-3-The-GPIB-Addressing-Protocol"><a href="#3-3-The-GPIB-Addressing-Protocol" class="headerlink" title="3.3 - The GPIB Addressing Protocol"></a>3.3 - The GPIB Addressing Protocol</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/GPIBAddressingProtocol.png" class width="1724139754287"><blockquote><p>Bits 0 through 4 indicate the primary address of the device, for which the Talker&#x2F;Listener assignment is intended. If bit 5 is high, the device should listen. If bit 6 is high, the device should talk. Bit 7 is a “don’t care” bit. Its value is ignored, so it is interpreted as a value of zero in command messages.</p><p>Each device on the bus must have a unique address. This address consists of a primary address (PAD) and a secondary address (SAD). As you can see from Figure 1, five of the data lines are used to indicate the GPIB primary address. This means that you could have a value from 0 to 31, for a total of 32 (2 to the power of 5) addresses; however, <strong>PAD 31 is never used as a primary address</strong>, because it is used for special command messages. This leaves a total of 31 possible primary addresses. The Controller-In-Charge (CIC) for a bus is almost always at PAD 0, so the instruments on a bus can have primary addresses from 1 to 30. A common mistake in working with the GPIB is assigning the same address to the controller board and the instrument, which will result in an EADR error (addressing error).</p><p>The GPIB secondary address is identical in its range of 0 to 30, which allows for a total of 961 (31 x 31) possible GPIB addresses, but the secondary address is very rarely used (the SAD is typically set to zero). Talker&#x2F;Listener assignments are part of the primary addressing information, so with PADs you use either bit 6 or bit 5 when you send a command message. This might prompt you to ask, “How do I send the SAD information?” For secondary addresses, you set both bits 6 and 5 high when you send a command message. If you need to communicate with a device that has a secondary address, you need to indicate its primary address first and then immediately indicate its secondary address.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Command codes</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNL  0x3f  <span class="comment">// GPIB unlisten command</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNT  0x5f  <span class="comment">// GPIB untalk command</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GTL  0x01  <span class="comment">// GPIB go to local</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDC  0x04  <span class="comment">// GPIB selected device clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPC  0x05  <span class="comment">// GPIB parallel poll configure</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET  0x08  <span class="comment">// GPIB group execute trigger</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCT  0x09  <span class="comment">// GPIB take control</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLO  0x11  <span class="comment">// GPIB local lock out</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCL  0x14  <span class="comment">// GPIB device clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPU  0x15  <span class="comment">// GPIB parallel poll unconfigure</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPE  0x18  <span class="comment">// GPIB serial poll enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPD  0x19  <span class="comment">// GPIB serial poll disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPE  0x60  <span class="comment">// GPIB parallel poll enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPD  0x70  <span class="comment">// GPIB parallel poll disable</span></span></span><br></pre></td></tr></table></figure><h4 id="3-4-Handshake"><a href="#3-4-Handshake" class="headerlink" title="3.4 - Handshake"></a>3.4 - Handshake</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/gpib%E6%8F%A1%E6%89%8B.png" class width="1724138669001"><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/HandShakeandManageMentLines.png" class width="1724142045673"><h4 id="3-5-Information-transfer"><a href="#3-5-Information-transfer" class="headerlink" title="3.5 - Information transfer"></a>3.5 - Information transfer</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/%E6%B3%A2%E5%BD%A2%E6%96%87%E4%BB%B6.png" class><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/%E5%86%99%E6%93%8D%E4%BD%9C.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通信系统初始阶段</span></span><br><span class="line">step <span class="number">1</span> ： Controller send IFC </span><br><span class="line">初始化GPIB信道，表明自己是Controller（controller in charge）</span><br><span class="line"><span class="comment">// 数据交互阶段</span></span><br><span class="line">step <span class="number">2</span> ： Controller unassert ATN</span><br><span class="line">表示当前数据线上传输的为控制命令</span><br><span class="line">step <span class="number">3</span> ： Controller send command</span><br><span class="line">控制器通过发送command来确定总线上的Talker与Listener</span><br><span class="line">step <span class="number">4</span> ： Listener assert NRFD NDAC</span><br><span class="line">接收方初始化自己状态，先表示自己未准备好</span><br><span class="line">step <span class="number">5</span> ： Listener unassert NRFD</span><br><span class="line">接收方表示自己准备好接受数据</span><br><span class="line">step <span class="number">6</span> ： Controller assert ATN</span><br><span class="line">表示当前数据线上传输的为数据信息</span><br><span class="line">step <span class="number">7</span> ： Talker send a Byte message</span><br><span class="line">发送方监听到接收方准备完成后，发送一字节的数据，ASCII形式（<span class="number">7</span>bit）由<span class="number">8</span>分DIO线发送</span><br><span class="line">step <span class="number">8</span> ： Talker assert DAV</span><br><span class="line">发送放通过DAV表示数据有效可以接受</span><br><span class="line">step <span class="number">9</span> ： Listener unassert NDAC</span><br><span class="line">接收方表示数据接受完毕</span><br><span class="line">step <span class="number">10</span> ： Talker unassert DAV</span><br><span class="line">发送方取消数据有效信号</span><br><span class="line">......(重复step <span class="number">6</span> ~ step <span class="number">9</span>)</span><br><span class="line"><span class="comment">// 交互结束阶段</span></span><br><span class="line">step <span class="number">11</span> ： Talker assert EOI</span><br><span class="line">发送方数据发送完毕后出发EOI信号表示数据发送完毕</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-GPIB驱动层（NI驱动）"><a href="#4-GPIB驱动层（NI驱动）" class="headerlink" title="4 - GPIB驱动层（NI驱动）"></a>4 - GPIB驱动层（NI驱动）</h2><h4 id="4-1-Status"><a href="#4-1-Status" class="headerlink" title="4.1 - Status"></a>4.1 - Status</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// GPIB status bit vector: global variable ibsta and wait mask</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR   (1&lt;&lt;15)  <span class="comment">// Error detected</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMO  (1&lt;&lt;14)  <span class="comment">// Timeout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END   (1&lt;&lt;13)  <span class="comment">// EOI or EOS detected</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRQI  (1&lt;&lt;12)  <span class="comment">// SRQ detected by CIC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQS   (1&lt;&lt;11)  <span class="comment">// Device needs service</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMPL  (1&lt;&lt;8)   <span class="comment">// I/O completed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOK   (1&lt;&lt;7)   <span class="comment">// Local lockout state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REM   (1&lt;&lt;6)   <span class="comment">// Remote state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIC   (1&lt;&lt;5)   <span class="comment">// Controller-in-Charge</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATN   (1&lt;&lt;4)   <span class="comment">// Attention asserted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACS  (1&lt;&lt;3)   <span class="comment">// Talker active</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LACS  (1&lt;&lt;2)   <span class="comment">// Listener active</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTAS  (1&lt;&lt;1)   <span class="comment">// Device trigger state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCAS  (1&lt;&lt;0)   <span class="comment">// Device clear state</span></span></span><br></pre></td></tr></table></figure><h4 id="4-2-Error"><a href="#4-2-Error" class="headerlink" title="4.2 - Error"></a>4.2 - Error</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Error messages returned in global variable iberr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDVR   0  <span class="comment">// System error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECIC   1  <span class="comment">// Function requires GPIB board to be CIC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOL   2  <span class="comment">// Write function detected no Listeners</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADR   3  <span class="comment">// Interface board not addressed correctly</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARG   4  <span class="comment">// Invalid argument to function call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESAC   5  <span class="comment">// Function requires GPIB board to be SAC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EABO   6  <span class="comment">// I/O operation aborted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEB   7  <span class="comment">// Non-existent interface board</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDMA   8  <span class="comment">// Error performing DMA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOIP  10  <span class="comment">// I/O operation started before previous operation completed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECAP  11  <span class="comment">// No capability for intended operation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFSO  12  <span class="comment">// File system operation error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUS  14  <span class="comment">// Command error during device call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTB  15  <span class="comment">// Serial poll status byte lost</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRQ  16  <span class="comment">// SRQ remains asserted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETAB  20  <span class="comment">// The return buffer is full</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELCK  21  <span class="comment">// Address or board is locked</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARM  22  <span class="comment">// The ibnotify Callback failed to rearm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHDL  23  <span class="comment">// The input handle is invalid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWIP  26  <span class="comment">// Wait already in progress on input ud</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERST  27  <span class="comment">// The event notification was cancelled due to a reset of the interface</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPWR  28  <span class="comment">// The system or board has lost power or gone to standby</span></span></span><br></pre></td></tr></table></figure><h4 id="4-3-EOS-EOI"><a href="#4-3-EOS-EOI" class="headerlink" title="4.3 - EOS&amp;EOI"></a>4.3 - EOS&amp;EOI</h4><blockquote><p>GPIB data transfers are terminated either when the GPIB EOI line is asserted with the last byte of a transfer or when a preconfigured end-of-string (EOS) character is transmitted. By default, EOI is asserted with the last byte of writes and the EOS modes are disabled.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// EOS mode bits</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN   (1&lt;&lt;12)  <span class="comment">// Eight bit compare</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XEOS  (1&lt;&lt;11)  <span class="comment">// Send END with EOS byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REOS  (1&lt;&lt;10)  <span class="comment">// Terminate read on EOS</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>EOS comparison method</strong>—This indicates whether the EOS byte  has seven or eight significant bits. For a 7-bit EOS byte, the eighth bit of the  EOS byte is ignored.  </li><li><strong>EOS write method</strong>—If this is enabled, the GPIB EOI line is  automatically asserted when the EOS byte is written to the GPIB. If the buffer  passed into an  ibwrt call contains five occurrences of  the EOS byte, the EOI line is asserted as each of the five EOS bytes are written  to the GPIB. If an ibwrt buffer does not contain an  occurrence of the EOS byte, the EOI line is not asserted (unless the EOT mode is  enabled, in which case the EOI line is asserted with the last byte of the  write).  </li><li><strong>EOS read method</strong>—If this is enabled, ibrd, ibrda, and ibrdf calls are terminated when the EOS byte is detected  on the GPIB, when the GPIB EOI line is asserted, or when the specified count is  reached. If the EOS read method is disabled, ibrd,  ibrda, and ibrdf calls  terminate only when the GPIB EOI line is asserted or the specified count has  been read.</li></ul></blockquote><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/EOI&EOS.png" class width="1724205780470"><h4 id="4-4-Timeout"><a href="#4-4-Timeout" class="headerlink" title="4.4 - Timeout"></a>4.4 - Timeout</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timeout values and meanings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TNONE    0   <span class="comment">// Infinite timeout (disabled)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10us    1   <span class="comment">// Timeout of 10 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30us    2   <span class="comment">// Timeout of 30 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100us   3   <span class="comment">// Timeout of 100 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300us   4   <span class="comment">// Timeout of 300 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1ms     5   <span class="comment">// Timeout of 1 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T3ms     6   <span class="comment">// Timeout of 3 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10ms    7   <span class="comment">// Timeout of 10 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30ms    8   <span class="comment">// Timeout of 30 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100ms   9   <span class="comment">// Timeout of 100 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300ms  10   <span class="comment">// Timeout of 300 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1s     11   <span class="comment">// Timeout of 1 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T3s     12   <span class="comment">// Timeout of 3 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10s    13   <span class="comment">// Timeout of 10 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30s    14   <span class="comment">// Timeout of 30 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100s   15   <span class="comment">// Timeout of 100 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300s   16   <span class="comment">// Timeout of 300 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1000s  17   <span class="comment">// Timeout of 1000 s (ideal)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>The timeout period is used to select the maximum duration allowed for a synchronous I&#x2F;O operation (for example, ibrd and ibwrt) or for an ibwait or ibnotify operation with TIMO in the wait mask. If the<br>operation does not complete before the timeout period elapses, the operation is aborted and TIMO is returned in Ibsta. The timeout values represent the minimum timeout period. The actual period could be longer</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统杂谈</title>
      <link href="/2024/08/14/computerMem/"/>
      <url>/2024/08/14/computerMem/</url>
      
        <content type="html"><![CDATA[<h2 id="一、存储系统总览"><a href="#一、存储系统总览" class="headerlink" title="一、存储系统总览"></a>一、存储系统总览</h2><img src="/2024/08/14/computerMem/08/14/computerMem/computer_memflow.png" class title="存储系统流程图"><h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 - 概念"></a>1 - 概念</h3><p>​内存（主存）为计算机进行活动过程中用来存储活动数据的空间，比如计算的数据，执行的指令等</p><h3 id="2-内存构成"><a href="#2-内存构成" class="headerlink" title="2 - 内存构成"></a>2 - 内存构成</h3><p>​内存一般由DRAM芯片构成，DRAM芯片利用栅极电容存储信息，所以本质上存储的是电信号，同时栅极电容具有电容的特性，所以DRAM也存在刷新机制用于维护电信号。</p><p>​DRAM只是一个存储芯片，那么我们现在常说的内存条又是个什么鬼呢？</p><p>​一般来说，存储芯片所能容纳的数据量其实很有限，比如4K * 4bit（16 * 1024bit）数据量，也就是一个芯片可能只是以KB为单位的，而我们常说的内存条通常都是GB为单位，显而易见，内存条是存储芯片的集合，那么我们是怎么将一小个一小个的芯片组装成一整个内存条的呢？</p><p>​我们简单以8GB的内存条为例，假设内存条的引脚为64个，也就是说内存条可以一次传递64bit的数据，但是一个4K*4bit的芯片一次只能传输4bit的数据，所以我们怎么读出64bit数据？</p><h4 id="2-1-字位扩展"><a href="#2-1-字位扩展" class="headerlink" title="2.1 - 字位扩展"></a>2.1 - 字位扩展</h4><p>​显然，可以将16个存储芯片并排放在一起，16个芯片每个里面读出4bit，那么就读出了64bit，这种微观上读取多个芯片的位数从而达到宏观上的多位数据我们称之为 — <strong>位扩展</strong>。</p><p>​ok，现在我将16个芯片并排放一起了，那么现在这16个芯片的容量也才16*4K*4bit &#x3D; 32KB的容量，离我们8GB还差得远呢！我们有没有其他手段能够扩大容量呢？</p><p>​有！除了增加我们位数，我们还可以从另一个角度开始。</p><p>​8GB的内存条，我们一次读出来64bit，一共可以读1G次，也就是2^30次，也就是说我们以16个芯片为一组，那么拥有2^30组，所以我们可以考虑增加组数！我们将一次性读出来的64bit称之为字长，所以我们这种扩展方式称之为 — <strong>字扩展</strong>。</p><p>​而这两种协同扩展空间构建8GB空间的方法就称为 — <strong>字位同时扩展</strong>。</p><p>​补充思考一下存在的一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在的情景是：</span><br><span class="line">我们需要将 4K * 4bit的存储芯片，构造成 1G * 64bit的内存条，进行位扩展后我们构造成了 4K * 64bit的存储组，我们说需要再进行字扩展才能构造1G * 64bit的内存条，现在我们进行字扩展，那么就需要1G / 4K = 256K个组，请问：硬件是如何确定我们读的是那个组呢？</span><br><span class="line">    回答： 显然我们内存条数据线是64位，地址线为30位（表示有多少个组，显然有1G个，对应的就是30bit）。而我们构建出4K * 64bit有256K个，表示选择那个组需要18位，芯片内有4K个4bit，每个芯片中选中哪4个bit需要12bit，一共刚好30bit</span><br></pre></td></tr></table></figure><blockquote><p>更详细的物理构成参考：<a href="https://lzz5235.github.io/2015/04/21/memory.html">https://lzz5235.github.io/2015/04/21/memory.html</a></p></blockquote><h4 id="2-2-内存刷新机制"><a href="#2-2-内存刷新机制" class="headerlink" title="2.2 - 内存刷新机制"></a>2.2 - 内存刷新机制</h4><p>​经过上述的方案我们解决了如何用这一个个小的存储芯片构造成我们生活中用的存储条的问题，但是还存在一个问题：反过来想一下，我们使用的存储芯片是DRAM，为栅极电容存储方式，这种方式我们之前提到过是一种破坏性读出的存储方式，同时电容也是易失的，所以我们还要考虑维护数据，也就是我们常说的DRAM刷新机制保证原来的数据仍然存在。</p><p>​那么通常有几种内存刷新机制如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意： 刷新是以行为单位</span></span><br><span class="line">集中刷新：专门腾出一块时间刷新所有行</span><br><span class="line">分散刷新：每行读完立马就刷新</span><br><span class="line">异步刷新：保证电容消散的时间中能够将每行都刷新完毕</span><br></pre></td></tr></table></figure><p>​ok，拥有了刷新机制，我们就保证了数据在内存中是时刻有效存在的，现在可以放心去操作了！但是麻烦还是存在！我们CPU的工作速度是相当之快的，但是内存条的工作速度却是有限的，现在你还搞出这个刷新，这下更慢了，难道我的CPU每次存取完下次来敲门的时候还得等你穿裤子吗？？？</p><h4 id="2-3-多模块存储器"><a href="#2-3-多模块存储器" class="headerlink" title="2.3 - 多模块存储器"></a>2.3 - 多模块存储器</h4><p>​根据上面的描述，我们总结一下当前的场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在一张8G（1G*64bit）的内存条，我们读取64bit后假设需要进行刷新恢复电容，我们将内存条从读出数据到刷新完数据进行下一次读取成为内存条的工作周期，1s中内存条工作多少次成为内存条的主频，同理CPU也有主频，随便参考一下市面上的cpu和内存条我们可以知道：</span><br><span class="line">酷睿i5 12490f的主频为 - 4.6GHz</span><br><span class="line">阿斯嘉特8GB内存条主频为 - 3200MHz（不考虑其他因素如DDR4）</span><br><span class="line">可以看出CPU的工作频率是高于内存条的工作频率，考虑极端情况CPU多次进行访存，那么这时候CPU是需要等待内存条存取数据并且进行刷新数据后再进行下一次读取操作，这时候就大大拖了CPU的工作效率。</span><br></pre></td></tr></table></figure><p>​那么我们有没有办法解决呢？</p><p>​那必须是有的！</p><p>​我们可以考虑再多加一张内存条，在这个内存条进行刷新的过程中，我们可以访问另一张内存条，听起来或许没有什么技术含量，但是这其中也有一些小问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们CPU进行地址访问的时候，可不管你是第几个内存条，我只管给出地址，我们怎么处理才能分散我们的访问次序呢？</span><br><span class="line">   比如：我现在想要访问的次序是0x0001、0x0002、0x0003、0x0004，请问怎么处理？</span><br><span class="line">   学过数学的很容易知道，我们将数字对2取余就可以将一堆数字交替分散称两堆，同理我们将地址对2取余就可以映射到两个内存条中，换而言之，我们将地址交叉编址完成交替访问，从而将多个存储器并行工作。</span><br></pre></td></tr></table></figure><p>​我们将上述方案的方式称为 — <strong>低位交叉编址多体并行存储器</strong>。</p><p>​同时，提一嘴还存在一下两种模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单体多字：通过扩大字长扩大吞吐量</span><br><span class="line">高位交叉编址：通过高位编址从而完成存储体的并行访问</span><br></pre></td></tr></table></figure><blockquote><p>此处可进一步参考：<a href="https://developer.aliyun.com/article/1150147">https://developer.aliyun.com/article/1150147</a></p></blockquote><h3 id="3-内存地址"><a href="#3-内存地址" class="headerlink" title="3 - 内存地址"></a>3 - 内存地址</h3><p>​由上可知，内存存储的是电信号，本质上就是正负信号（0&#x2F;1），对应的就是bit位。在计算机系统中，通常使用字节作为单位用来存储8bit（1B &#x3D; 8b）的数据，当我们对每个字节进行编址就得到了整个内存的地址大小。内存地址也即<strong>物理地址</strong>，好比房间和房间号。</p><p>​研究一个问题：假设现在只有一个4GB的内存条，也就是物理内存只能访问到0x0000 ~0xFFFF地址大小，但是如果我的程序很大，比如占用了8个G（模型渲染、机器学习等），但是物理空间只有4GB大小，也就是说我8G的空间，只有4G的门牌号，剩余4G的空间系统里都查不到，这肯定是不合适的，但是我们可以很容易想到一个方法 — 拓展内存大小：</p><p>​我们给我们的主机加上内存条，拓展到8G大小这样不就行了吗？</p><p>​但是有两个缺点：1、贵</p><p>​       2、缓兵之计，要是下一次10G怎么办？</p><p>​有的人又会问，硬盘不贵，同等空间硬盘便宜多了，但是硬盘便宜的代价就是硬盘很慢，所以cpu不会直接同硬盘进行数据交互，cpu宝贵的资源超快的速度不可能每次都等待硬盘进行数据传输，所以我们需要的是一个机制—一个从根本上解决程序地址和物理地址不匹配的机制，那既然程序地址无法同物理地址一一对应，那么我们就可以将耦合解开来，采用别的方式完成程序地址到物理地址的转换，此处转换也即映射，此处程序地址就是我们要谈论的<strong>虚拟地址</strong>。</p><h3 id="4-内存数据获取方式"><a href="#4-内存数据获取方式" class="headerlink" title="4 - 内存数据获取方式"></a>4 - 内存数据获取方式</h3><p>​既然有了存放数据的空间，也知道这些空间的编号，那么我们获取数据的方式无非就是按照编号找到对应的空间，然后取出对应的数据。而编号就是我们的物理地址，找数据的过程就是对应选片读取的过程。</p><p>​如果现在编址空间为24bit表示大小，也就是0x000000~0xFFFFFF大小，如果我们将内存看作为一个矩阵空间（实际DRAM就是），每一行使用12bit容纳的空间，也就是每一行存储2^12（4096）B的数据，那么剩余12bit就成为了行号，此时我们就可称这24bit中，高12bit为行号，低12bit为列号，也称前者为行地址，后者为列地址。</p><p>​同时为了节省资源，现代计算机通常使用行列地址复用技术减少地址线的根数。那么此处实际上我们只需要12跟地址线就足以，当我们想要获取某一个单元的数据的时候，我们通常会选择先传送12bit的行地址进行行选通，再传送12bit列地址进行列选通从而完成寻址，随后将数据读出通过数据线传送到CPU中。</p><p>​</p><h2 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1 - 引言"></a>1 - 引言</h3><p>​我们知道，程序员写代码的时候不需要关心物理地址，访问都是通过指针或者索引或者其他形式去访问，既然底层是通过地址去获取存储单元中的数据，那么这一环节是如何转换的呢？</p><p>​以c为例，我们c代码是高级语言，代码执行过程可以有以下的执行过程：</p><img src="/2024/08/14/computerMem/08/14/computerMem/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" class title="程序执行过程"><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span>  <span class="comment">// 预处理阶段处理</span></span></span><br><span class="line"></span><br><span class="line">代码段  <span class="comment">// 编译 -》 汇编 -》 链接 形成基于整个程序空间的逻辑地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ok，现在我们经过了预处理、编译、汇编、链接从而形成了可执行程序，并且整个可执行程序中的数据或者指令也都被我们进行了编址，也就是拥有了基于程序这个空间的地址，那么为什么要进行装入操作呢？直接将可执行程序上CPU运行不就完事了吗？</p><p>​其实，在以前的单道处理系统中是这样的，但是考虑效率现在的多道批处理系统中并非如此，现在的cpu是属于并发（甚至并行）执行多个程序，也就是说多个程序可能都要存储在内存中，那么小程序还行，如果是大程序怎么在有限的内存中进行操作呢？</p><h3 id="2-虚拟地址"><a href="#2-虚拟地址" class="headerlink" title="2 - 虚拟地址"></a>2 - 虚拟地址</h3><p>​上文说到我们需要采用一种机制，解决物理地址有限的问题，我们称之为虚拟地址（逻辑地址）。物理地址受限于物理引脚的个数，物理引脚的个数确定了物理上能访问的空间大小，而虚拟地址则受限于os系统的架构，例如32位x86架构能够访问的空间大小和64位的x64架构能访问的空间大小则完全不同。</p><p>​以32位x86架构的系统为例，我们虚拟地址以32bit进行编制，那么我们能够访问的空间的大小就是0x00000000 ~0xFFFFFFFF地址范围，我们说为什么受限呢？可以想想，我们现在写好了程序，编译、汇编、链接这些操作都是在哪里进行处理的？ 那必须是os中处理，所以我们被人家改造成了人家的位数，合情合理。</p><p>​ok，现在我们的访问地址变大了，在程序的角度能访问的所有的房间都有门牌号了，但是实际的存储范围其实就那么大，我们上文中提到的解决方式是将虚拟地址与逻辑地址之间一一对应的关系改造为虚拟地址到物理地址之间映射的关系从而达到扩大程序地址空间的目的，那么接下来详细谈谈这个映射机制，从<strong>虚拟内存</strong>开始说起。</p><h3 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3 - 虚拟内存"></a>3 - 虚拟内存</h3><p>​我们说，物理地址空间能访问的空间大小称之为物理内存。那么逻辑地址（虚拟地址）能访问的空间大小则称之为虚拟内存。</p><p>​接下来我们考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们之前谈到数据是以二进制存储在内存中，也就是数据是bit位；同时我们谈到内存中对数据编址是通过字节的形式，也就是B字节；</span><br><span class="line">​请问：我们程序运行过程中从内存中获取数据是以bit还是B为单位获取？</span><br><span class="line">​答案：我们地址是按照B为单位进行编址，自然我们也是以B位单位获取数据</span><br></pre></td></tr></table></figure><p>​再考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设现在有以下的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：我们需要将32bit的空间大小映射到24bit空间中，应该怎么做？</span><br><span class="line">​答案：使用一个表，记录下来逻辑地址到物理地址之间的对应关系，拿到逻辑地址的时候查表获取对应的物理地址从而获取对应的数据。</span><br></pre></td></tr></table></figure><h4 id="3-1-页表"><a href="#3-1-页表" class="headerlink" title="3.1 - 页表"></a>3.1 - 页表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，页表存放在内存中。</p><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">还是以上的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：现在有一个int类型的数据，请问怎么访问获取这个int类型的数据呢（不考虑大端小端等，只说明大致过程）？</span><br><span class="line">​答案：int类型的数据占用4个字节，也就是要获取连续的4个地址中保存的bit数据，所以我们需要根据将连续的4个逻辑地址通过查找页表来获取对应4个地址的物理地址，从而在物理内存中获取真实的物理数据。</span><br><span class="line"></span><br><span class="line">我们可以发现，再此过程中进行了4次地址转换，获得了4个物理地址，从而获取到了对应的4个B的数据。但是这个过程中存在一个问题，就是页表中也存在4条逻辑地址到物理地址的映射记录，ok，可能4条映射表现出来的问题不够明显，现在考虑我们想要获取如果是1MB的数据，那么映射记录就变成了1M个；如果是1GB数据，那么映射记录就变成了1G个；同时可以计算：</span><br><span class="line">逻辑地址32bit=4B，物理地址24bit=3B；</span><br><span class="line">那么</span><br><span class="line">        1M个记录 = 1M*7B = 7MB；</span><br><span class="line">        1G个记录 = 1G*7B = 7GB；</span><br><span class="line">        可以看出页表占用的内存大小是相当大的。</span><br><span class="line">所以我们需要规避这种空间损耗，那么就必须增大映射的单位大小，换句话说就是将原来以B为单位映射改为以一堆B为单位进行映射，所以页表是以页为单位进行映射的。</span><br><span class="line"></span><br><span class="line">现在我们重新以页的方式进行映射，假设页的大小为1KB，那么此时1MB个数据就缩减为了1K个记录！</span><br></pre></td></tr></table></figure><h4 id="3-2-段表"><a href="#3-2-段表" class="headerlink" title="3.2 - 段表"></a>3.2 - 段表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，段表存放在内存中。</p><p>​同上，我们还存在一种映射方式是以段为单位进行映射，也就是表中存储的是段的逻辑地址到物理地址之间的映射关系，我们将在下一小节中说明这些差别。</p><h4 id="3-3-页、段、页框"><a href="#3-3-页、段、页框" class="headerlink" title="3.3 - 页、段、页框"></a>3.3 - 页、段、页框</h4><p>​上文分析，为了避免不必要的浪费，我们引入了<strong>页</strong>这个概念，用来将一个B之间的映射转换为一堆B之间的映射；</p><p>​那么<strong>段</strong>存在的意义就是将一堆B之间的映射进一步提升为一个模块之间的映射。</p><p>​例如，现在有两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​那么在os层面，这两个模块照样会经过编译、汇编、链接成为二进制机器语言，那么为了保证函数的完整性，我们提出将func1作为一个段，将func2作为一个段。但是我们知道函数编译出来的产物通常是指令，而不是每个函数的指令长度都是一样的，也就是段的长度受实际代码复杂度等因素影响，所以在段表中我们是需要记录段的长度。</p><p>​在虚拟内存层面我们交换的单位称之为<strong>页</strong>或者<strong>段</strong>，那么物理内存层面我们与之对应的单位也有名字，成为<strong>页框</strong>。</p><h4 id="3-4-虚拟地址（以页为例）"><a href="#3-4-虚拟地址（以页为例）" class="headerlink" title="3.4 - 虚拟地址（以页为例）"></a>3.4 - 虚拟地址（以页为例）</h4><p>​在引入了页这个概念后，我们的逻辑（虚拟）地址就可以划分为以下的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址 = 逻辑地址剩余位数 + 页占用的位数</span><br><span class="line"></span><br><span class="line">同时，我们进一步将名称规范一下，逻辑地址剩余位数表示的其实就是对页进行编址，所以称之为页号，表示是第几个页；</span><br><span class="line">也占用的位数其实就是一个页中的第几个字节（因为毕竟总的来说是按照字节编址的），所以可以成为块内偏移；那么我们可以进一步写为:</span><br><span class="line"></span><br><span class="line">逻辑地址 = 页号 + 块内偏移地址</span><br></pre></td></tr></table></figure><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">依旧是上述的情景：</span><br><span class="line">逻辑地址32bit，物理地址24bit，页的大小为1KB</span><br><span class="line">逻辑地址 = 22bit页号 + 10bit页内偏移地址</span><br><span class="line">按照这个逻辑，我们需要记录22bit也就是4M个页的映射记录在页表中，也就是页表的大小为：</span><br><span class="line">4M * （22 +14）bit = 4M * 36bit = 18MB</span><br><span class="line">这是个不小的数字，同时伴随着地址空间的增大，这个数字还会增大，如果使用单级页表需要耗费巨大的连续空间，os对于这种空间的管理需要一定的消耗，而且考虑到并不是所有页都会被使用，所以还会造成大量的空间浪费。</span><br><span class="line">因此引入了多级页表的机制用于减少损耗，提高效率。假设现在使用的是两级页表，那么逻辑地址就可变成：</span><br><span class="line">逻辑地址 = 11bit一级页号 + 11bit二级页号 + 10bit块内（页内）偏移</span><br></pre></td></tr></table></figure><p>​ok，上文提到页表是存储在内存中的，同时我们的页号需要在页表中进行查找，那么我们怎么找到页表呢？</p><p>答案是–<strong>页表始址寄存器</strong></p><p>​页表始址寄存器会记录页表在内存中的起始地址，从而找到页表。页表始址寄存器中的值需要程序上cpu处理初始化上下文环境由进程PCB中获得初始化寄存器中的值。</p><p>​所以我们具体查找流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step4： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step5： 根据物理页框号找到内存中对应的页</span><br><span class="line">step6： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多级页表（二级为例）</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据一级页号和页表始址寄存器中页表起始地址去匹配获得二级页表地址</span><br><span class="line">step4： 根据二级页号在二级页表中匹配真正记录页号到页框号映射的页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：页表中并不需要逐个比对，由于顺序一致，所以</span></span><br><span class="line">页表项地址 = 页表基址 + 页表项大小 × 页号</span><br></pre></td></tr></table></figure><p>​ok，那现在我们可以从上述流程发现（单级页表为例），我们地址转换一共进行了两次访存（访问内存）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次：去内存查找页表获得物理地址</span><br><span class="line">第二次：去内存获取数据</span><br></pre></td></tr></table></figure><p>​同时我们知道，cpu和内存的效率差距很大，所以每一次访存都是一次很大的损耗，那么有没有办法能够提高效率呢？</p><p>​答案肯定是有的，现在计算机系统集成了一套机制–TLB机制，也称之为快表，相对应的就把内存中的页表称之为慢表。</p><h4 id="3-5-局部性原理"><a href="#3-5-局部性原理" class="headerlink" title="3.5 - 局部性原理"></a>3.5 - 局部性原理</h4><p>​谈论快表之前，谈论一下在计算机设计中广泛用到（包括下文的cache系统）的局部性原理；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">时间局部性（Temporal Locality）:</span><br><span class="line"></span><br><span class="line">时间局部性指的是程序在某一时刻访问了某个存储位置后，短时间内可能会再次访问该位置。例如，循环中的变量或频繁使用的子程序都有很高的时间局部性。</span><br><span class="line">例子: 在一个循环中，多次访问相同的变量或数组元素。每次循环迭代时，程序都会访问同一个存储位置。</span><br><span class="line"></span><br><span class="line">空间局部性（Spatial Locality）:</span><br><span class="line"></span><br><span class="line">空间局部性指的是程序在访问某个存储位置时，它附近的存储位置在不久的将来也可能会被访问。这意味着，如果一个存储位置被访问了，存储器中相邻的位置很可能也会被访问。</span><br><span class="line">例子: 在访问数组中的一个元素后，程序很可能会访问相邻的元素。</span><br></pre></td></tr></table></figure><h4 id="3-6-快表（TLB）"><a href="#3-6-快表（TLB）" class="headerlink" title="3.6 - 快表（TLB）"></a>3.6 - 快表（TLB）</h4><p>​快表其实本质上是一个页表的缓存，采用的是相联存储器（硬件），集成在CPU中，速度很快。映入快表后，查找流程就转变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号查找快表，若查找到对应物理页框号直接跳转step5</span><br><span class="line">step4： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br></pre></td></tr></table></figure><h4 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 - 小结"></a>3.7 - 小结</h4><p>​程序编译为可执行程序(二进制文件—ELF文件)；</p><p>​CPU调度进程上处理机运行，同时从PCB中获取信息初始化上下文（包括页表始址寄存器等);</p><p>​取指执行阶段，访存获取指令；</p><p>​查找快表；</p><p>​查找页表；</p><p>​访问内存；</p><p><strong>注意：</strong>这其中还包括查找不命中的情况，并非如此简单顺利，后续有时间再补充！</p><p>​至此，这一部分就完结了！</p><img src="/2024/08/14/computerMem/08/14/computerMem/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" class title="逻辑地址映射关系"><h2 id="四、cache缓存"><a href="#四、cache缓存" class="headerlink" title="四、cache缓存"></a>四、cache缓存</h2><h3 id="1-引言-1"><a href="#1-引言-1" class="headerlink" title="1 - 引言"></a>1 - 引言</h3><p>​我们说物理内存是采用DRAM（动态随机存储器）构成，与CPU之间仍有效率差距，为了提高效率，同时践行局部性原理，引入内存的缓存机制-cache机制。</p><p>​cache采用SRAM（静态随机存储器）构成，比DRAM更快（同时也更贵）。</p><p>​cache作为内存的缓存，会保存部分内存的数据为了保证更快的访问，那么既然是保存部分数据，自然就涉及到以下的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 数据以什么形式保存在cache中</span><br><span class="line">2. 数据调入的方法</span><br><span class="line">3. 如何保证cache和主存数据的一致性</span><br><span class="line">4. 效率问题</span><br></pre></td></tr></table></figure><p>​下面将会对这些问题一一解答。</p><p>​同时上述的虚拟内存、逻辑地址体系完成了逻辑地址到物理地址的转换，现在我们终于拥有了物理地址，开始访问存储器……</p><h3 id="2-数据以什么形式保存在cache中"><a href="#2-数据以什么形式保存在cache中" class="headerlink" title="2 - 数据以什么形式保存在cache中"></a>2 - 数据以什么形式保存在cache中</h3><p>​既然作为内存的副本（缓存），那首先必要的就肯定是<strong>内存中的数据</strong>。</p><p>​那是不是只存储数据就ok了呢，我们从前往后推理一下即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设现在cache中只有内存中的数据：</span><br><span class="line">CPU现在访问的地址为0xfffff1，同时我们假设主存中该地址对应的数据已经把副本放在了cache中，请问CPU去缓存中该如何找到想要的数据呢？</span><br><span class="line">你也许懂了，哦~原来我访问存储器一直都是按照内存地址访问的，现在访问cache并没有对应的物理地址，所以我们得重新加上物理地址，但是cache既然只保存一部分内存中的数据，我难道得重新给cache进行编址吗？</span><br></pre></td></tr></table></figure><p>​显然，上述的推理是合理的。</p><p>​但是，没有必要！因为我们cache是SRAM存储单元构建，该单元的存储速度很快并且存储的数据量也没有内存中那么多，所以没有必要将访问内存的地址线访问存储空间不大的cache，同时减少了资源的浪费。</p><p>​cache采用的是另一套匹配逻辑 — <strong>标签</strong>。</p><p>​同上述虚拟地址与物理地址之间映射的逻辑，我们cache与主存之间的数据交换仍然采用的是一堆字节之间的交换，在主存中我们称为数据块，在cache中我们称为cache行。</p><p>​我们将一个主存块挪到cache行中，需要对这个cache行进行标记，表示对应的是哪一个主存块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用逻辑地址访问cache，由于cache行保存的是主存块的副本，所以cache行内的地址等于主存块中的地址。剩下的就是保存主存块到cache行中的映射关系。</span><br><span class="line">我们将块内地址占用的bit位剥离，如何将剩余部分利用起来构建映射关系呢？（你可能会问，为什么我一定要用剩余部分构建映射关系呢？我就不能用其他手段吗？答案是——不能，因为从CPU的角度来看，CPU只考虑我给你一个输入——逻辑地址，你存储系统能不能给我一个想要的输出——指令或数据，所以我们能够利用的只有逻辑地址）</span><br></pre></td></tr></table></figure><h4 id="2-1-cache映射"><a href="#2-1-cache映射" class="headerlink" title="2.1 cache映射"></a>2.1 cache映射</h4><p>​通常会采用以下几种方式来实现映射逻辑</p><ol><li><p><strong>直接映射</strong>：按照cache行的个数，将主存中不同地方的主存块映射到cache中确定的行——即对cache整个取模</p></li><li><p><strong>全相联映射</strong>：主存中的任意块可以随机放在cache中的任意一行</p></li><li><p><strong>组相联映射</strong>：将cache行进行分组，主存中不同地方的主存块映射到cache中确定的组，组内随机安置——即对cache组取模</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们再详细考虑一下，这几种映射条件下数据访问的流程是什么：</span><br><span class="line">1. 直接映射</span><br><span class="line">这种模式下，由于主存中的每个主存块都会确切的映射到cache中确切的行，所以我们只需要访问对应的行来判定是不是我们需要访问的主存块即可。那么就引入几个需要搞清楚的点：</span><br><span class="line">a. 为什么说主存块既然都映射到了cache中确切的行，我们还需要判断这个这个主存块呢？</span><br><span class="line">答：cache只是主存的副本，容量远小于主存，必然会存在多个主存块映射到同一个cache行，方便起见，以10进制为例，cache只有两行，主存有4个块，那么是不是0、2块都会映射到0行呢？</span><br><span class="line">b. 我们应该如何判定是不是我们需要访问的主存块呢？</span><br><span class="line">答：既然涉及到校验，那必然存在唯一键值，这很容易理解，我们只需要校验这个块对应的键值和我们要找的键值是不是一直就知道是不是我们想要的，同时这个键值必须是每个块都拥有的独一无二的，显然，地址自带这种特性，独一无二、每个块都有。</span><br><span class="line">   有的人可能会说，那就ok了，我就将地址保存下来，完了你想要哪个，我给你一个个的比对这些块的地址剩余部分是不是相同就完事了；甚至有的人可能会说，什么剩余部分，搞这么麻烦，我给你全地址全部保存下来，剩的麻烦了。没问题，从逻辑上来说，这能不能解决问题？当然可以，逻辑上一点毛病没有，但是我们要考虑，我们在研究的是一个高精密的凝聚人类智慧结晶的东西，我们得考虑效率，得考虑空间，得考虑最优化！</span><br><span class="line">   所以，我们需要思考，能不能更进一步，尽可能的少用点空间达到同样的效果呢，毕竟多存储一个bit，每个行就多一个bit，整个cache还得了？</span><br><span class="line">   从上文我们可以得知，我们的逻辑地址低几位表示块内地址，这几个cache和主存一样，我们把它单独拿出来用于找到想要的块后访问块内想要的存储单元，这一部分完全可以不用当作校验的部分，再进一步思考，既然直接映射是映射到确切的行，是不是说这个映射花费的bit也可以不用，因为这是确定的（或许你有点难理解什么叫映射花费的bit是确定的，举例，现在cache有2行，我们访问第7个主存块，7对应二进制111，对应的是那个行呢？我们对2取模，也就是1，那么7会被映射到1上面，我们说验证的根本原因是可能存在相同的映射，比如1号主存块，他也是映射到1行的，对应二进制为001，所以我们可以观察，这个去摸需要的bit为在我们验证的时候是不需要的，因为每一个映射到这个块的这一bit位都是一样的，所以我们只需要验证剩下的00和11是否一样就行了），所以我们去除了确定的，剩下的不确定的唯一的bit就是我们需要记录下来的！我们称之为 - 标签，也就是Tag位。</span><br><span class="line">   直接映射地址 = Tag + 行号 + 块内地址</span><br><span class="line">2. 全相连映射</span><br><span class="line">逻辑同直接映射，但是由于映射也是不确定的（主存块中的任意块都可以映射到cache中的任意行中），所以上面的映射bit也算到Tag的bit中</span><br><span class="line">全相联映射 = Tag + 块内地址</span><br><span class="line">3. 组相连映射</span><br><span class="line">逻辑同直接映射，但是这里确定的是组，所以映射bit为组数占用的bit</span><br><span class="line">组相联映射 = Tag + 组号 + 块内地址</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-cache中保存的数据"><a href="#2-2-cache中保存的数据" class="headerlink" title="2.2 cache中保存的数据"></a>2.2 cache中保存的数据</h4><p>​噢~原来cache中还得存储 Tag 、行号 、还有块内地址啊！</p><p>​我相信，肯定有人看到这里还是这个观念，我只能说，这些走马观花没有思考的人别学了，你学不会的……</p><p>​根据上面的分析，我们大概能知道：<br>​由于cache保存的是主存块的副本，所以主存块中的数据是肯定需要保存到cache中的；</p><p>​同时为了保证对应行是我们需要的主存块，我们还得记录对应的唯一标签，我们经过上面的分析，采用的是物理地址中”不确定“的那些bit，也就是上面的Tag位。</p><p>​over，<em><strong>目前</strong></em>来说，只有这些！</p><p>​有的人可能会问，那你上面的这些行号、组号还有块内地址这些是用来干啥的？</p><p>​没办法，我们从访问存储系统的层面再解释一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU给出逻辑地址，通过一系列转换（参考上面虚拟内存一章节），转换为物理地址访问存储系统获取想要的数据（或指令），存储系统拿到物理地址，根据自己的映射逻辑（上面几种映射方式），比如直接映射，就根据物理地址中对应于行号的bit去对应的行找，通过比对Tag来判定是不是自己想要的那个主存块，如果是想要的主存块，那么就根据物理地址中的块内地址，访问cache行（本质上就是访问内存块，因为cache行是主存块的副本），从而获取到对应的数据（或指令）。</span><br></pre></td></tr></table></figure><p>​善于思考的人再读完这段之后肯定会存在疑问：</p><ol><li><p>cache是一开始就有内存的副本吗？</p></li><li><p>要是我访问的行不是我想要的块，也就是说Tag匹配失败，怎么办？</p></li><li><p>如果我现在不是读，我现在是写，那我怎么保证你这个所谓副本和真实数据的一致性？</p></li></ol><pre><code>我们将在下面一一解答这些问题！</code></pre><h3 id="3-数据调入"><a href="#3-数据调入" class="headerlink" title="3 - 数据调入"></a>3 - 数据调入</h3><p>​<strong>显然，刚开始cache是空的！</strong></p><p>​为什么？我们从cache的组成入手，我们从上文的分析知道cache是由SRAM构成，这玩意是需要电的，断电肯定数据就没了，又不是持久化存储，比如磁盘，所以举一个极端的例子，刚开机的时候，你cache中怎么可能有数据嘛！</p><p>​那么我们上文中谈了这么多，你现在又跟我说，cache中根本没有数据，你耍我？？？？</p><p>​当然不是，cache中没有数据，并不代表永远没有数据，既然是副本，我们直接从主存中调过来不就行了！</p><p>​所以，这里就涉及到几个问题：</p><ol><li>什么时候怎么调入？</li><li>调入的时候没有位置了怎么办？</li></ol><h4 id="3-1-什么时候怎么调入"><a href="#3-1-什么时候怎么调入" class="headerlink" title="3.1 什么时候怎么调入"></a>3.1 什么时候怎么调入</h4><p>​没办法，由于cache事先也不知道CPU会访问到主存中的哪些块，所以只能在CPU访问的时候，发现cache中没有想要的行，这个时候把主存中对应的块调入。</p><p>​但是，这里涉及一个概念需要注意一下：<br><strong>缺页</strong>：我们将这个访问cache中发现没有命中的行为称之为缺页，这是个异常状态。</p><p>​同时，我们还需要注意一个小细节：请问，我们访问cache没有命中，这个时候我们去访问了主存，请问我们是直接访问主存后再调入？还是先调入cache后再访问主存？还是想调入cache后再访问cache呢？</p><p>​从CPU的角度来说，访问cache只是众多指令中的一个，既然作为指令执行过程中的异常，那么这个异常被OS解决后还需要重新执行这条异常的指令，所以解决异常就是将主存块调入cache行中的过程，重新执行这条指令就是重新访问cache的过程。<br>（注：作者印象中貌似不知道哪本黑书还是啥的，提到过也可以用硬件完成调入的过程，直接访问主存，所以此处存疑点）</p><h4 id="3-2-调入的时候没有位置了怎么办？"><a href="#3-2-调入的时候没有位置了怎么办？" class="headerlink" title="3.2 调入的时候没有位置了怎么办？"></a>3.2 调入的时候没有位置了怎么办？</h4><p>​考虑cache所有行都已经又记录了，现在访问一个全新的主存块，先去cache行中找有没有对应的记录，发现没有，需要进行主存块调块，但是cache已经行满，怎么处理？</p><p>​这时候就需要OS进行介入，从cache中选择一个行踢出去，腾出一个位置给现在访问的行调入。</p><p>​那怎么选择呢？OS怎么知道应该选择哪个行呢？？</p><p>​这就涉及到Cache的<strong>调度算法</strong>：</p><p>​<strong>FIFO：</strong>先调入的cache行先替换</p><p>​<strong>LRU：</strong>最近一段时间没有被访问的行先替换</p><p>​<strong>LFU：</strong>最近一段时间访问次数最少的行先替换</p><p>​<strong>RAND：</strong>随机选一个行进行替换</p><p>​这里对LRU和LFU做个通俗的解释，剩下两个比较容易理解。我们怎么理解这两个概念呢？最大的区别就是：LRU关注的是某一个行最近有没有被访问过，不管你总的来说被访问了几次，只要你最近被访问过，那么你的优先级就最低，就最不容易被换出去；LFU关注的是每一个行被访问的次数，访问次数最低的优先级最高，最容易被访问出去；</p><p>​在硬件层面，这两个逻辑都是用计数器完成的，具体逻辑不再赘述，较容易理解。</p><p>​ok，我们解决了数据块调入调出问题，但是不难发现，这里面还涉及到一个问题：</p><p>​既然cache中保存的是主存的副本，请问现在如果存在一个cache行被我们所改动，请问现在调出的时候怎么办？这就涉及到下一个章节了。</p><h3 id="4-如何保证cache和主存数据的一致性"><a href="#4-如何保证cache和主存数据的一致性" class="headerlink" title="4 - 如何保证cache和主存数据的一致性"></a>4 - 如何保证cache和主存数据的一致性</h3><p>[参考]: <a href="https://www.cnblogs.com/exungsh/p/15846630.html">https://www.cnblogs.com/exungsh/p/15846630.html</a>“为什么写回法搭配写分配法，全写法搭配非写分配法？写回法和全写法在cache上是固定的吗?”</p><p>​读数据不会造成数据更改，所以一般在写操作中，为了保证cache和主存的数据一致性，我们很容易想到的几个点:</p><ol><li>如果<strong>写</strong>命中cache，那么表示cache和主存中都有这一块数据，此时我们同时修改cache中的副本和主存中的数据块，我们有专业名词，称之为 —— <strong>全写法</strong></li><li>如果没有<strong>写</strong>命中主存，那么表示只有主存中有这个数据块，此时我们将数据块调入到cache中再修改cache，我们称之为 —— <strong>写分配法</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">那么我们不妨思考一下，如果当我们写命中的时候采用全写法，写不命中的时候采用写分配法，那么问：</span><br><span class="line">如果我们写的是 A——A——A——A</span><br><span class="line">那么访问流程为：</span><br><span class="line">1.写A不命中，访问主存调入A块放入cache，修改A块（1次访问主存调入cache，1次写cache，1次写主存）</span><br><span class="line">2.写A命中，同时写主存和cache（1次写主存，1次写cache）</span><br><span class="line">3.重复上述2次</span><br><span class="line">一共1次访问主存调cache，4次写cache，3次写主存</span><br><span class="line">显然我们可以发现，其实我们可以对上述进行优化：</span><br><span class="line">既然我们命中时会同时对cache和主存进行写，是否在不命中时不需要这些骚操作，直接写主存减少一次copy和写cache呢？</span><br></pre></td></tr></table></figure><ol start="3"><li>我们将上述不命中的时候直接写主存(<strong>通常会copy修改后的主存到cache行中</strong>)而不访问cache的行为称之为 —— <strong>非写分配法</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同样我们可以反过来思考一下，既然我们没有命中的时候会将主存块copy到cache行中，是否命中的时候可以只写cache从而减少写主存的操作呢？</span><br><span class="line">显然是的，但是考虑如果只修改cache而不考虑修改主存，那么是不是就不能完成数据一致性的需求了？怎么办？？</span><br><span class="line">既然是先访问cache，也就是说如果cache中有这个主存块，那么CPU获取到的数据就一直是最新的最正确的，我们考虑那么多干什么？CPU拿到的东西是对的不就行了？</span><br><span class="line">结合上一小节不难发现，cache中的行是可能被替换的，当cache未命中并且cache中没有多余的行提供给主存块调入的时候就会根据替换算法从cache行中选择替换出的行。</span><br><span class="line">那么这个时候我们修改的东西还在这个行中，显而易见我们在这个时候将cache中的数据直接覆盖到主存块中的老数据即可解决问题！</span><br></pre></td></tr></table></figure><ol start="4"><li>我们将上述写命中时候不写主存，当cache行被调出的时候再写主存的行为称之为 —— <strong>写回法</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同时需要注意的一点是，我们的cache并不是每次调出的时候都是被修改的cache行，如果调出的cache行没有被修改过，也就是和调入的时候数据一致，那么此时就没必要再将cache行覆盖主存块，因为会消耗一次主存写操作的耗时，这相对于cache和cpu系统是相当大的耗时！</span><br><span class="line"></span><br><span class="line">为了避免这一点，我们在每一个cache行中添加一位**修改位**，我们也称之为**脏位**，所以注意，此时我们cache行中存储的数据变成了：</span><br><span class="line"></span><br><span class="line">cache行 = 脏位 + Tag位 + 数据块</span><br></pre></td></tr></table></figure><p>​那么我们可以总结一下为了保持数据的一致性，我么通常采用两种搭配方式：</p><ol><li>全写法 + 非写分配法（相比于&lt;全写 + 写分配&gt;减少一次copy和写cache操作）</li><li>写回法 + 写分配法（相比于&lt;全写 + 写分配&gt;延迟主存写从而减少n次主存写操作）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那么，请问写回法 + 非写分配法可不可行？</span><br><span class="line">显然相比于&lt;写回法 + 写分配法&gt;使用了耗时更多的写主存操作！！！！</span><br></pre></td></tr></table></figure><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 - 小结"></a>5 - 小结</h3><h2 id="五、磁盘"><a href="#五、磁盘" class="headerlink" title="五、磁盘"></a>五、磁盘</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
