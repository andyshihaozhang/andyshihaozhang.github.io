<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/03/hello-world/"/>
      <url>/2024/09/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+gitblog搭建记录</title>
      <link href="/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/08/20/hexo-gitblog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-git部署绑定域名"><a href="#1-git部署绑定域名" class="headerlink" title="1 - git部署绑定域名"></a>1 - git部署绑定域名</h2><p>转载：<a href="https://jacckx.me/2021/02/28/Hexo_Custom_Domain/">https://jacckx.me/2021/02/28/Hexo_Custom_Domain/</a></p><h2 id="2-butterfly魔改教程"><a href="#2-butterfly魔改教程" class="headerlink" title="2 - butterfly魔改教程"></a>2 - butterfly魔改教程</h2><p>转载：<a href="https://www.fomal.cc/posts/eec9786.html">https://www.fomal.cc/posts/eec9786.html</a></p><h2 id="3-hexo博客迁移"><a href="#3-hexo博客迁移" class="headerlink" title="3 - hexo博客迁移"></a>3 - hexo博客迁移</h2><p>当前方案转载：<a href="https://blog.csdn.net/K1052176873/article/details/122879462">https://blog.csdn.net/K1052176873/article/details/122879462</a></p><p>完美方案转载：<a href="https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html">https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html</a></p><h2 id="4-hexo新环境安装失败"><a href="#4-hexo新环境安装失败" class="headerlink" title="4 - hexo新环境安装失败"></a>4 - hexo新环境安装失败</h2><p>清除原代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy null</span><br><span class="line">npm config set https-proxy null</span><br></pre></td></tr></table></figure><p>查看代理是否为null</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get proxy</span><br><span class="line">npm config get https-proxy</span><br></pre></td></tr></table></figure><p>安装cnpm环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IEEE488概述</title>
      <link href="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-IEEE488简介"><a href="#1-IEEE488简介" class="headerlink" title="1 - IEEE488简介"></a>1 - IEEE488简介</h2><p>​<strong>IEEE-488</strong> 是一种由<a href="https://zh.wikipedia.org/wiki/%E6%83%A0%E6%99%AE%E5%85%AC%E5%8F%B8">惠普公司</a>（现为<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E6%8D%B7%E5%80%AB%E7%A7%91%E6%8A%80">安捷伦科技</a>及<a href="https://zh.wikipedia.org/wiki/%E6%98%AF%E5%BE%B7%E7%A7%91%E6%8A%80">是德科技</a>）在1960年代开发的HP-IB（<em>Hewlett-Packard Interface Bus</em>，惠普接口总线）短程通信<a href="https://zh.wikipedia.org/wiki/%E6%80%BB%E7%BA%BF">总线</a>规范。随后成为了标准，并通称为<strong>GP-IB</strong>（<em>General Purpose Interface Bus</em>，通用接口总线）。</p><h2 id="2-GPIB总线构成"><a href="#2-GPIB总线构成" class="headerlink" title="2 - GPIB总线构成"></a>2 - GPIB总线构成</h2><h4 id="2-1-GPIB接口示例图"><a href="#2-1-GPIB接口示例图" class="headerlink" title="2.1 - GPIB接口示例图"></a>2.1 - GPIB接口示例图</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/IEEE_488_Connector.jpg" class title="IEEE_488_Connector"><h4 id="2-2-GPIB总线说明"><a href="#2-2-GPIB总线说明" class="headerlink" title="2.2 - GPIB总线说明"></a>2.2 - GPIB总线说明</h4><p><strong>Data Lines</strong></p><blockquote><p>The eight data lines, DIO1 through DIO8, carry both data and command messages. The state of the Attention (ATN) line determines whether the information is data or commands. All commands and most data use the 7-bit ASCII or ISO code set, in which case the eighth bit, DIO8, is either unused or used for parity.  </p></blockquote><p><strong>Handshake Lines</strong> </p><blockquote><p>Three lines asynchronously control the transfer of message bytes between devices. The process is called a 3-wire interlocked handshake. It guarantees that message bytes on the data lines are sent and received without transmission error. </p><p><strong>NRFD (not ready for data)</strong> - Indicates when a device is ready or not ready to receive a message byte. The line is driven by all devices when receiving commands, by Listeners when receiving data messages, and by the Talker when enabling the HS488 protocol.  </p><p><strong>NDAC (not data accepted)</strong> - Indicates when a device has or has not accepted a message byte. The line is driven by all devices when receiving commands, and by Listeners when receiving data messages.  </p><p><strong>DAV (data valid)</strong> - Tells when the signals on the data lines are stable (valid) and can beaccepted safely by devices. The Controller drives DAV when sending commands, and the Talker drives DAV when sending data messages.  </p></blockquote><p><strong>Interface Management Lines</strong> </p><blockquote><p>Five lines manage the flow of information across the interface: </p><p><strong>ATN (attention)</strong> - The Controller drives ATN true when it uses the data lines to send commands, and drives ATN false when a Talker can send data messages. </p><p><strong>IFC (interface clear)</strong> - The System Controller drives the IFC line to initialize the bus and become CIC.  </p><p><strong>REN (remote enable)</strong> - The System Controller drives the REN line, which is used to place devices in remote or local program mode.  </p><p><strong>SRQ (service request)</strong> - Any device can drive the SRQ line to asynchronously request service from the Controller.  </p><p><strong>EOI (end or identify)</strong> - The EOI line has two purposes - The Talker uses the EOI line to mark the end of a message string, and the Controller uses the EOI line to tell devices to identify their response in a parallel poll.</p></blockquote><h2 id="3-GPIB物理层"><a href="#3-GPIB物理层" class="headerlink" title="3 - GPIB物理层"></a>3 - GPIB物理层</h2><h4 id="3-1-Controllers-Talkers-and-Listeners"><a href="#3-1-Controllers-Talkers-and-Listeners" class="headerlink" title="3.1 - Controllers, Talkers, and Listeners"></a>3.1 - Controllers, Talkers, and Listeners</h4><blockquote><ul><li><strong>Controllers</strong> govern the flow of information on the bus by issuing Talker and Listener assignments to other devices on the bus. They respond to service requests from instruments, and they can pass control of the bus to other Controllers. There can be only one Controller-In-Charge (CIC or System Controller) per bus, which is responsible for overall management of the bus.</li><li><strong>Talkers</strong> place information on the data lines of the bus, but only when a Controller instructs them to do so. Only one device can talk at a time.</li><li><strong>Listeners</strong> retrieve information from the data lines of the bus, but only when a Controller instructs them to do so. Any number of devices can listen at the same time.</li></ul></blockquote><p><strong>注意：</strong></p><blockquote><p>Some devices are capable of playing more than one role. A digital voltmeter, for example, can be a Talker and a Listener. If your system has a National Instruments GPIB interface and software installed, it can function as a Talker, Listener, and Controller.</p></blockquote><h4 id="3-2-Command-Messages-vs-Data-Messages"><a href="#3-2-Command-Messages-vs-Data-Messages" class="headerlink" title="3.2 - Command Messages vs. Data Messages"></a>3.2 - Command Messages vs. Data Messages</h4><blockquote><p>GPIB Controllers use command messages to tell devices (instruments or other Controllers) when they can talk to provide information to the bus and when they can listen to information on the bus. The Talker and Listener assignments are sent as command messages, while the information is passed as data messages.</p><p>The major difference between a command message and a data message is the state of the Attention (ATN) line, which is one of the bus management lines. If the ATN line is asserted, any messages sent on the data lines are heard by all devices, and they are understood to be command messages. If the ATN line is not asserted, only the devices that were addressed to listen may receive the messages on the data lines.  </p></blockquote><h4 id="3-3-The-GPIB-Addressing-Protocol"><a href="#3-3-The-GPIB-Addressing-Protocol" class="headerlink" title="3.3 - The GPIB Addressing Protocol"></a>3.3 - The GPIB Addressing Protocol</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/GPIBAddressingProtocol.png" class width="1724139754287"><blockquote><p>Bits 0 through 4 indicate the primary address of the device, for which the Talker&#x2F;Listener assignment is intended. If bit 5 is high, the device should listen. If bit 6 is high, the device should talk. Bit 7 is a “don’t care” bit. Its value is ignored, so it is interpreted as a value of zero in command messages.</p><p>Each device on the bus must have a unique address. This address consists of a primary address (PAD) and a secondary address (SAD). As you can see from Figure 1, five of the data lines are used to indicate the GPIB primary address. This means that you could have a value from 0 to 31, for a total of 32 (2 to the power of 5) addresses; however, <strong>PAD 31 is never used as a primary address</strong>, because it is used for special command messages. This leaves a total of 31 possible primary addresses. The Controller-In-Charge (CIC) for a bus is almost always at PAD 0, so the instruments on a bus can have primary addresses from 1 to 30. A common mistake in working with the GPIB is assigning the same address to the controller board and the instrument, which will result in an EADR error (addressing error).</p><p>The GPIB secondary address is identical in its range of 0 to 30, which allows for a total of 961 (31 x 31) possible GPIB addresses, but the secondary address is very rarely used (the SAD is typically set to zero). Talker&#x2F;Listener assignments are part of the primary addressing information, so with PADs you use either bit 6 or bit 5 when you send a command message. This might prompt you to ask, “How do I send the SAD information?” For secondary addresses, you set both bits 6 and 5 high when you send a command message. If you need to communicate with a device that has a secondary address, you need to indicate its primary address first and then immediately indicate its secondary address.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Command codes</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNL  0x3f  <span class="comment">// GPIB unlisten command</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNT  0x5f  <span class="comment">// GPIB untalk command</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GTL  0x01  <span class="comment">// GPIB go to local</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDC  0x04  <span class="comment">// GPIB selected device clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPC  0x05  <span class="comment">// GPIB parallel poll configure</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET  0x08  <span class="comment">// GPIB group execute trigger</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCT  0x09  <span class="comment">// GPIB take control</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LLO  0x11  <span class="comment">// GPIB local lock out</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCL  0x14  <span class="comment">// GPIB device clear</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPU  0x15  <span class="comment">// GPIB parallel poll unconfigure</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPE  0x18  <span class="comment">// GPIB serial poll enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPD  0x19  <span class="comment">// GPIB serial poll disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPE  0x60  <span class="comment">// GPIB parallel poll enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPD  0x70  <span class="comment">// GPIB parallel poll disable</span></span></span><br></pre></td></tr></table></figure><h4 id="3-4-Handshake"><a href="#3-4-Handshake" class="headerlink" title="3.4 - Handshake"></a>3.4 - Handshake</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/gpib%E6%8F%A1%E6%89%8B.png" class width="1724138669001"><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/HandShakeandManageMentLines.png" class width="1724142045673"><h4 id="3-5-Information-transfer"><a href="#3-5-Information-transfer" class="headerlink" title="3.5 - Information transfer"></a>3.5 - Information transfer</h4><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/%E6%B3%A2%E5%BD%A2%E6%96%87%E4%BB%B6.png" class><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/%E5%86%99%E6%93%8D%E4%BD%9C.png" class><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通信系统初始阶段</span></span><br><span class="line">step <span class="number">1</span> ： Controller send IFC </span><br><span class="line">初始化GPIB信道，表明自己是Controller（controller in charge）</span><br><span class="line"><span class="comment">// 数据交互阶段</span></span><br><span class="line">step <span class="number">2</span> ： Controller unassert ATN</span><br><span class="line">表示当前数据线上传输的为控制命令</span><br><span class="line">step <span class="number">3</span> ： Controller send command</span><br><span class="line">控制器通过发送command来确定总线上的Talker与Listener</span><br><span class="line">step <span class="number">4</span> ： Listener assert NRFD NDAC</span><br><span class="line">接收方初始化自己状态，先表示自己未准备好</span><br><span class="line">step <span class="number">5</span> ： Listener unassert NRFD</span><br><span class="line">接收方表示自己准备好接受数据</span><br><span class="line">step <span class="number">6</span> ： Controller assert ATN</span><br><span class="line">表示当前数据线上传输的为数据信息</span><br><span class="line">step <span class="number">7</span> ： Talker send a Byte message</span><br><span class="line">发送方监听到接收方准备完成后，发送一字节的数据，ASCII形式（<span class="number">7</span>bit）由<span class="number">8</span>分DIO线发送</span><br><span class="line">step <span class="number">8</span> ： Talker assert DAV</span><br><span class="line">发送放通过DAV表示数据有效可以接受</span><br><span class="line">step <span class="number">9</span> ： Listener unassert NDAC</span><br><span class="line">接收方表示数据接受完毕</span><br><span class="line">step <span class="number">10</span> ： Talker unassert DAV</span><br><span class="line">发送方取消数据有效信号</span><br><span class="line">......(重复step <span class="number">6</span> ~ step <span class="number">9</span>)</span><br><span class="line"><span class="comment">// 交互结束阶段</span></span><br><span class="line">step <span class="number">11</span> ： Talker assert EOI</span><br><span class="line">发送方数据发送完毕后出发EOI信号表示数据发送完毕</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-GPIB驱动层（NI驱动）"><a href="#4-GPIB驱动层（NI驱动）" class="headerlink" title="4 - GPIB驱动层（NI驱动）"></a>4 - GPIB驱动层（NI驱动）</h2><h4 id="4-1-Status"><a href="#4-1-Status" class="headerlink" title="4.1 - Status"></a>4.1 - Status</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// GPIB status bit vector: global variable ibsta and wait mask</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR   (1&lt;&lt;15)  <span class="comment">// Error detected</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMO  (1&lt;&lt;14)  <span class="comment">// Timeout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END   (1&lt;&lt;13)  <span class="comment">// EOI or EOS detected</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRQI  (1&lt;&lt;12)  <span class="comment">// SRQ detected by CIC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RQS   (1&lt;&lt;11)  <span class="comment">// Device needs service</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMPL  (1&lt;&lt;8)   <span class="comment">// I/O completed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOK   (1&lt;&lt;7)   <span class="comment">// Local lockout state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REM   (1&lt;&lt;6)   <span class="comment">// Remote state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIC   (1&lt;&lt;5)   <span class="comment">// Controller-in-Charge</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATN   (1&lt;&lt;4)   <span class="comment">// Attention asserted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACS  (1&lt;&lt;3)   <span class="comment">// Talker active</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LACS  (1&lt;&lt;2)   <span class="comment">// Listener active</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTAS  (1&lt;&lt;1)   <span class="comment">// Device trigger state</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCAS  (1&lt;&lt;0)   <span class="comment">// Device clear state</span></span></span><br></pre></td></tr></table></figure><h4 id="4-2-Error"><a href="#4-2-Error" class="headerlink" title="4.2 - Error"></a>4.2 - Error</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Error messages returned in global variable iberr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDVR   0  <span class="comment">// System error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECIC   1  <span class="comment">// Function requires GPIB board to be CIC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOL   2  <span class="comment">// Write function detected no Listeners</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADR   3  <span class="comment">// Interface board not addressed correctly</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARG   4  <span class="comment">// Invalid argument to function call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESAC   5  <span class="comment">// Function requires GPIB board to be SAC</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EABO   6  <span class="comment">// I/O operation aborted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEB   7  <span class="comment">// Non-existent interface board</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDMA   8  <span class="comment">// Error performing DMA</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOIP  10  <span class="comment">// I/O operation started before previous operation completed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECAP  11  <span class="comment">// No capability for intended operation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFSO  12  <span class="comment">// File system operation error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUS  14  <span class="comment">// Command error during device call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTB  15  <span class="comment">// Serial poll status byte lost</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRQ  16  <span class="comment">// SRQ remains asserted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETAB  20  <span class="comment">// The return buffer is full</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELCK  21  <span class="comment">// Address or board is locked</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARM  22  <span class="comment">// The ibnotify Callback failed to rearm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHDL  23  <span class="comment">// The input handle is invalid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWIP  26  <span class="comment">// Wait already in progress on input ud</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERST  27  <span class="comment">// The event notification was cancelled due to a reset of the interface</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPWR  28  <span class="comment">// The system or board has lost power or gone to standby</span></span></span><br></pre></td></tr></table></figure><h4 id="4-3-EOS-EOI"><a href="#4-3-EOS-EOI" class="headerlink" title="4.3 - EOS&amp;EOI"></a>4.3 - EOS&amp;EOI</h4><blockquote><p>GPIB data transfers are terminated either when the GPIB EOI line is asserted with the last byte of a transfer or when a preconfigured end-of-string (EOS) character is transmitted. By default, EOI is asserted with the last byte of writes and the EOS modes are disabled.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// EOS mode bits</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN   (1&lt;&lt;12)  <span class="comment">// Eight bit compare</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XEOS  (1&lt;&lt;11)  <span class="comment">// Send END with EOS byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REOS  (1&lt;&lt;10)  <span class="comment">// Terminate read on EOS</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>EOS comparison method</strong>—This indicates whether the EOS byte  has seven or eight significant bits. For a 7-bit EOS byte, the eighth bit of the  EOS byte is ignored.  </li><li><strong>EOS write method</strong>—If this is enabled, the GPIB EOI line is  automatically asserted when the EOS byte is written to the GPIB. If the buffer  passed into an  ibwrt call contains five occurrences of  the EOS byte, the EOI line is asserted as each of the five EOS bytes are written  to the GPIB. If an ibwrt buffer does not contain an  occurrence of the EOS byte, the EOI line is not asserted (unless the EOT mode is  enabled, in which case the EOI line is asserted with the last byte of the  write).  </li><li><strong>EOS read method</strong>—If this is enabled, ibrd, ibrda, and ibrdf calls are terminated when the EOS byte is detected  on the GPIB, when the GPIB EOI line is asserted, or when the specified count is  reached. If the EOS read method is disabled, ibrd,  ibrda, and ibrdf calls  terminate only when the GPIB EOI line is asserted or the specified count has  been read.</li></ul></blockquote><img src="/2024/08/19/IEEE488%E6%A6%82%E8%BF%B0/08/19/IEEE488%E6%A6%82%E8%BF%B0/EOI&EOS.png" class width="1724205780470"><h4 id="4-4-Timeout"><a href="#4-4-Timeout" class="headerlink" title="4.4 - Timeout"></a>4.4 - Timeout</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timeout values and meanings</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TNONE    0   <span class="comment">// Infinite timeout (disabled)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10us    1   <span class="comment">// Timeout of 10 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30us    2   <span class="comment">// Timeout of 30 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100us   3   <span class="comment">// Timeout of 100 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300us   4   <span class="comment">// Timeout of 300 us (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1ms     5   <span class="comment">// Timeout of 1 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T3ms     6   <span class="comment">// Timeout of 3 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10ms    7   <span class="comment">// Timeout of 10 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30ms    8   <span class="comment">// Timeout of 30 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100ms   9   <span class="comment">// Timeout of 100 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300ms  10   <span class="comment">// Timeout of 300 ms (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1s     11   <span class="comment">// Timeout of 1 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T3s     12   <span class="comment">// Timeout of 3 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T10s    13   <span class="comment">// Timeout of 10 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T30s    14   <span class="comment">// Timeout of 30 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T100s   15   <span class="comment">// Timeout of 100 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T300s   16   <span class="comment">// Timeout of 300 s (ideal)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1000s  17   <span class="comment">// Timeout of 1000 s (ideal)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>The timeout period is used to select the maximum duration allowed for a synchronous I&#x2F;O operation (for example, ibrd and ibwrt) or for an ibwait or ibnotify operation with TIMO in the wait mask. If the<br>operation does not complete before the timeout period elapses, the operation is aborted and TIMO is returned in Ibsta. The timeout values represent the minimum timeout period. The actual period could be longer</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统杂谈</title>
      <link href="/2024/08/14/computerMem/"/>
      <url>/2024/08/14/computerMem/</url>
      
        <content type="html"><![CDATA[<h2 id="一、存储系统总览"><a href="#一、存储系统总览" class="headerlink" title="一、存储系统总览"></a>一、存储系统总览</h2><img src="/2024/08/14/computerMem/08/14/computerMem/computer_memflow.png" class title="存储系统流程图"><h2 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 - 概念"></a>1 - 概念</h3><p>​内存（主存）为计算机进行活动过程中用来存储活动数据的空间，比如计算的数据，执行的指令等</p><h3 id="2-内存构成"><a href="#2-内存构成" class="headerlink" title="2 - 内存构成"></a>2 - 内存构成</h3><p>​内存一般由DRAM芯片构成，DRAM芯片利用栅极电容存储信息，所以本质上存储的是电信号，同时栅极电容具有电容的特性，所以DRAM也存在刷新机制用于维护电信号。</p><p>​DRAM只是一个存储芯片，那么我们现在常说的内存条又是个什么鬼呢？</p><p>​一般来说，存储芯片所能容纳的数据量其实很有限，比如4K * 4bit（16 * 1024bit）数据量，也就是一个芯片可能只是以KB为单位的，而我们常说的内存条通常都是GB为单位，显而易见，内存条是存储芯片的集合，那么我们是怎么将一小个一小个的芯片组装成一整个内存条的呢？</p><p>​我们简单以8GB的内存条为例，假设内存条的引脚为64个，也就是说内存条可以一次传递64bit的数据，但是一个4K*4bit的芯片一次只能传输4bit的数据，所以我们怎么读出64bit数据？</p><h4 id="2-1-字位扩展"><a href="#2-1-字位扩展" class="headerlink" title="2.1 - 字位扩展"></a>2.1 - 字位扩展</h4><p>​显然，可以将16个存储芯片并排放在一起，16个芯片每个里面读出4bit，那么就读出了64bit，这种微观上读取多个芯片的位数从而达到宏观上的多位数据我们称之为 — <strong>位扩展</strong>。</p><p>​ok，现在我将16个芯片并排放一起了，那么现在这16个芯片的容量也才16*4K*4bit &#x3D; 32KB的容量，离我们8GB还差得远呢！我们有没有其他手段能够扩大容量呢？</p><p>​有！除了增加我们位数，我们还可以从另一个角度开始。</p><p>​8GB的内存条，我们一次读出来64bit，一共可以读1G次，也就是2^30次，也就是说我们以16个芯片为一组，那么拥有2^30组，所以我们可以考虑增加组数！我们将一次性读出来的64bit称之为字长，所以我们这种扩展方式称之为 — <strong>字扩展</strong>。</p><p>​而这两种协同扩展空间构建8GB空间的方法就称为 — <strong>字位同时扩展</strong>。</p><p>​补充思考一下存在的一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在的情景是：</span><br><span class="line">我们需要将 4K * 4bit的存储芯片，构造成 1G * 64bit的内存条，进行位扩展后我们构造成了 4K * 64bit的存储组，我们说需要再进行字扩展才能构造1G * 64bit的内存条，现在我们进行字扩展，那么就需要1G / 4K = 256K个组，请问：硬件是如何确定我们读的是那个组呢？</span><br><span class="line">    回答： 显然我们内存条数据线是64位，地址线为30位（表示有多少个组，显然有1G个，对应的就是30bit）。而我们构建出4K * 64bit有256K个，表示选择那个组需要18位，芯片内有4K个4bit，每个芯片中选中哪4个bit需要12bit，一共刚好30bit</span><br></pre></td></tr></table></figure><blockquote><p>更详细的物理构成参考：<a href="https://lzz5235.github.io/2015/04/21/memory.html">https://lzz5235.github.io/2015/04/21/memory.html</a></p></blockquote><h4 id="2-2-内存刷新机制"><a href="#2-2-内存刷新机制" class="headerlink" title="2.2 - 内存刷新机制"></a>2.2 - 内存刷新机制</h4><p>​经过上述的方案我们解决了如何用这一个个小的存储芯片构造成我们生活中用的存储条的问题，但是还存在一个问题：反过来想一下，我们使用的存储芯片是DRAM，为栅极电容存储方式，这种方式我们之前提到过是一种破坏性读出的存储方式，同时电容也是易失的，所以我们还要考虑维护数据，也就是我们常说的DRAM刷新机制保证原来的数据仍然存在。</p><p>​那么通常有几种内存刷新机制如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意： 刷新是以行为单位</span></span><br><span class="line">集中刷新：专门腾出一块时间刷新所有行</span><br><span class="line">分散刷新：每行读完立马就刷新</span><br><span class="line">异步刷新：保证电容消散的时间中能够将每行都刷新完毕</span><br></pre></td></tr></table></figure><p>​ok，拥有了刷新机制，我们就保证了数据在内存中是时刻有效存在的，现在可以放心去操作了！但是麻烦还是存在！我们CPU的工作速度是相当之快的，但是内存条的工作速度却是有限的，现在你还搞出这个刷新，这下更慢了，难道我的CPU每次存取完下次来敲门的时候还得等你穿裤子吗？？？</p><h4 id="2-3-多模块存储器"><a href="#2-3-多模块存储器" class="headerlink" title="2.3 - 多模块存储器"></a>2.3 - 多模块存储器</h4><p>​根据上面的描述，我们总结一下当前的场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在一张8G（1G*64bit）的内存条，我们读取64bit后假设需要进行刷新恢复电容，我们将内存条从读出数据到刷新完数据进行下一次读取成为内存条的工作周期，1s中内存条工作多少次成为内存条的主频，同理CPU也有主频，随便参考一下市面上的cpu和内存条我们可以知道：</span><br><span class="line">酷睿i5 12490f的主频为 - 4.6GHz</span><br><span class="line">阿斯嘉特8GB内存条主频为 - 3200MHz（不考虑其他因素如DDR4）</span><br><span class="line">可以看出CPU的工作频率是高于内存条的工作频率，考虑极端情况CPU多次进行访存，那么这时候CPU是需要等待内存条存取数据并且进行刷新数据后再进行下一次读取操作，这时候就大大拖了CPU的工作效率。</span><br></pre></td></tr></table></figure><p>​那么我们有没有办法解决呢？</p><p>​那必须是有的！</p><p>​我们可以考虑再多加一张内存条，在这个内存条进行刷新的过程中，我们可以访问另一张内存条，听起来或许没有什么技术含量，但是这其中也有一些小问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们CPU进行地址访问的时候，可不管你是第几个内存条，我只管给出地址，我们怎么处理才能分散我们的访问次序呢？</span><br><span class="line">   比如：我现在想要访问的次序是0x0001、0x0002、0x0003、0x0004，请问怎么处理？</span><br><span class="line">   学过数学的很容易知道，我们将数字对2取余就可以将一堆数字交替分散称两堆，同理我们将地址对2取余就可以映射到两个内存条中，换而言之，我们将地址交叉编址完成交替访问，从而将多个存储器并行工作。</span><br></pre></td></tr></table></figure><p>​我们将上述方案的方式称为 — <strong>低位交叉编址多体并行存储器</strong>。</p><p>​同时，提一嘴还存在一下两种模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单体多字：通过扩大字长扩大吞吐量</span><br><span class="line">高位交叉编址：通过高位编址从而完成存储体的并行访问</span><br></pre></td></tr></table></figure><blockquote><p>此处可进一步参考：<a href="https://developer.aliyun.com/article/1150147">https://developer.aliyun.com/article/1150147</a></p></blockquote><h3 id="3-内存地址"><a href="#3-内存地址" class="headerlink" title="3 - 内存地址"></a>3 - 内存地址</h3><p>​由上可知，内存存储的是电信号，本质上就是正负信号（0&#x2F;1），对应的就是bit位。在计算机系统中，通常使用字节作为单位用来存储8bit（1B &#x3D; 8b）的数据，当我们对每个字节进行编址就得到了整个内存的地址大小。内存地址也即<strong>物理地址</strong>，好比房间和房间号。</p><p>​研究一个问题：假设现在只有一个4GB的内存条，也就是物理内存只能访问到0x0000 ~0xFFFF地址大小，但是如果我的程序很大，比如占用了8个G（模型渲染、机器学习等），但是物理空间只有4GB大小，也就是说我8G的空间，只有4G的门牌号，剩余4G的空间系统里都查不到，这肯定是不合适的，但是我们可以很容易想到一个方法 — 拓展内存大小：</p><p>​我们给我们的主机加上内存条，拓展到8G大小这样不就行了吗？</p><p>​但是有两个缺点：1、贵</p><p>​       2、缓兵之计，要是下一次10G怎么办？</p><p>​有的人又会问，硬盘不贵，同等空间硬盘便宜多了，但是硬盘便宜的代价就是硬盘很慢，所以cpu不会直接同硬盘进行数据交互，cpu宝贵的资源超快的速度不可能每次都等待硬盘进行数据传输，所以我们需要的是一个机制—一个从根本上解决程序地址和物理地址不匹配的机制，那既然程序地址无法同物理地址一一对应，那么我们就可以将耦合解开来，采用别的方式完成程序地址到物理地址的转换，此处转换也即映射，此处程序地址就是我们要谈论的<strong>虚拟地址</strong>。</p><h3 id="4-内存数据获取方式"><a href="#4-内存数据获取方式" class="headerlink" title="4 - 内存数据获取方式"></a>4 - 内存数据获取方式</h3><p>​既然有了存放数据的空间，也知道这些空间的编号，那么我们获取数据的方式无非就是按照编号找到对应的空间，然后取出对应的数据。而编号就是我们的物理地址，找数据的过程就是对应选片读取的过程。</p><p>​如果现在编址空间为24bit表示大小，也就是0x000000~0xFFFFFF大小，如果我们将内存看作为一个矩阵空间（实际DRAM就是），每一行使用12bit容纳的空间，也就是每一行存储2^12（4096）B的数据，那么剩余12bit就成为了行号，此时我们就可称这24bit中，高12bit为行号，低12bit为列号，也称前者为行地址，后者为列地址。</p><p>​同时为了节省资源，现代计算机通常使用行列地址复用技术减少地址线的根数。那么此处实际上我们只需要12跟地址线就足以，当我们想要获取某一个单元的数据的时候，我们通常会选择先传送12bit的行地址进行行选通，再传送12bit列地址进行列选通从而完成寻址，随后将数据读出通过数据线传送到CPU中。</p><p>​</p><h2 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1 - 引言"></a>1 - 引言</h3><p>​我们知道，程序员写代码的时候不需要关心物理地址，访问都是通过指针或者索引或者其他形式去访问，既然底层是通过地址去获取存储单元中的数据，那么这一环节是如何转换的呢？</p><p>​以c为例，我们c代码是高级语言，代码执行过程可以有以下的执行过程：</p><img src="/2024/08/14/computerMem/08/14/computerMem/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" class title="程序执行过程"><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span>  <span class="comment">// 预处理阶段处理</span></span></span><br><span class="line"></span><br><span class="line">代码段  <span class="comment">// 编译 -》 汇编 -》 链接 形成基于整个程序空间的逻辑地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ok，现在我们经过了预处理、编译、汇编、链接从而形成了可执行程序，并且整个可执行程序中的数据或者指令也都被我们进行了编址，也就是拥有了基于程序这个空间的地址，那么为什么要进行装入操作呢？直接将可执行程序上CPU运行不就完事了吗？</p><p>​其实，在以前的单道处理系统中是这样的，但是考虑效率现在的多道批处理系统中并非如此，现在的cpu是属于并发（甚至并行）执行多个程序，也就是说多个程序可能都要存储在内存中，那么小程序还行，如果是大程序怎么在有限的内存中进行操作呢？</p><h3 id="2-虚拟地址"><a href="#2-虚拟地址" class="headerlink" title="2 - 虚拟地址"></a>2 - 虚拟地址</h3><p>​上文说到我们需要采用一种机制，解决物理地址有限的问题，我们称之为虚拟地址（逻辑地址）。物理地址受限于物理引脚的个数，物理引脚的个数确定了物理上能访问的空间大小，而虚拟地址则受限于os系统的架构，例如32位x86架构能够访问的空间大小和64位的x64架构能访问的空间大小则完全不同。</p><p>​以32位x86架构的系统为例，我们虚拟地址以32bit进行编制，那么我们能够访问的空间的大小就是0x00000000 ~0xFFFFFFFF地址范围，我们说为什么受限呢？可以想想，我们现在写好了程序，编译、汇编、链接这些操作都是在哪里进行处理的？ 那必须是os中处理，所以我们被人家改造成了人家的位数，合情合理。</p><p>​ok，现在我们的访问地址变大了，在程序的角度能访问的所有的房间都有门牌号了，但是实际的存储范围其实就那么大，我们上文中提到的解决方式是将虚拟地址与逻辑地址之间一一对应的关系改造为虚拟地址到物理地址之间映射的关系从而达到扩大程序地址空间的目的，那么接下来详细谈谈这个映射机制，从<strong>虚拟内存</strong>开始说起。</p><h3 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3 - 虚拟内存"></a>3 - 虚拟内存</h3><p>​我们说，物理地址空间能访问的空间大小称之为物理内存。那么逻辑地址（虚拟地址）能访问的空间大小则称之为虚拟内存。</p><p>​接下来我们考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们之前谈到数据是以二进制存储在内存中，也就是数据是bit位；同时我们谈到内存中对数据编址是通过字节的形式，也就是B字节；</span><br><span class="line">​请问：我们程序运行过程中从内存中获取数据是以bit还是B为单位获取？</span><br><span class="line">​答案：我们地址是按照B为单位进行编址，自然我们也是以B位单位获取数据</span><br></pre></td></tr></table></figure><p>​再考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设现在有以下的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：我们需要将32bit的空间大小映射到24bit空间中，应该怎么做？</span><br><span class="line">​答案：使用一个表，记录下来逻辑地址到物理地址之间的对应关系，拿到逻辑地址的时候查表获取对应的物理地址从而获取对应的数据。</span><br></pre></td></tr></table></figure><h4 id="3-1-页表"><a href="#3-1-页表" class="headerlink" title="3.1 - 页表"></a>3.1 - 页表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，页表存放在内存中。</p><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">还是以上的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：现在有一个int类型的数据，请问怎么访问获取这个int类型的数据呢（不考虑大端小端等，只说明大致过程）？</span><br><span class="line">​答案：int类型的数据占用4个字节，也就是要获取连续的4个地址中保存的bit数据，所以我们需要根据将连续的4个逻辑地址通过查找页表来获取对应4个地址的物理地址，从而在物理内存中获取真实的物理数据。</span><br><span class="line"></span><br><span class="line">我们可以发现，再此过程中进行了4次地址转换，获得了4个物理地址，从而获取到了对应的4个B的数据。但是这个过程中存在一个问题，就是页表中也存在4条逻辑地址到物理地址的映射记录，ok，可能4条映射表现出来的问题不够明显，现在考虑我们想要获取如果是1MB的数据，那么映射记录就变成了1M个；如果是1GB数据，那么映射记录就变成了1G个；同时可以计算：</span><br><span class="line">逻辑地址32bit=4B，物理地址24bit=3B；</span><br><span class="line">那么</span><br><span class="line">        1M个记录 = 1M*7B = 7MB；</span><br><span class="line">        1G个记录 = 1G*7B = 7GB；</span><br><span class="line">        可以看出页表占用的内存大小是相当大的。</span><br><span class="line">所以我们需要规避这种空间损耗，那么就必须增大映射的单位大小，换句话说就是将原来以B为单位映射改为以一堆B为单位进行映射，所以页表是以页为单位进行映射的。</span><br><span class="line"></span><br><span class="line">现在我们重新以页的方式进行映射，假设页的大小为1KB，那么此时1MB个数据就缩减为了1K个记录！</span><br></pre></td></tr></table></figure><h4 id="3-2-段表"><a href="#3-2-段表" class="headerlink" title="3.2 - 段表"></a>3.2 - 段表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，段表存放在内存中。</p><p>​同上，我们还存在一种映射方式是以段为单位进行映射，也就是表中存储的是段的逻辑地址到物理地址之间的映射关系，我们将在下一小节中说明这些差别。</p><h4 id="3-3-页、段、页框"><a href="#3-3-页、段、页框" class="headerlink" title="3.3 - 页、段、页框"></a>3.3 - 页、段、页框</h4><p>​上文分析，为了避免不必要的浪费，我们引入了<strong>页</strong>这个概念，用来将一个B之间的映射转换为一堆B之间的映射；</p><p>​那么<strong>段</strong>存在的意义就是将一堆B之间的映射进一步提升为一个模块之间的映射。</p><p>​例如，现在有两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​那么在os层面，这两个模块照样会经过编译、汇编、链接成为二进制机器语言，那么为了保证函数的完整性，我们提出将func1作为一个段，将func2作为一个段。但是我们知道函数编译出来的产物通常是指令，而不是每个函数的指令长度都是一样的，也就是段的长度受实际代码复杂度等因素影响，所以在段表中我们是需要记录段的长度。</p><p>​在虚拟内存层面我们交换的单位称之为<strong>页</strong>或者<strong>段</strong>，那么物理内存层面我们与之对应的单位也有名字，成为<strong>页框</strong>。</p><h4 id="3-4-虚拟地址（以页为例）"><a href="#3-4-虚拟地址（以页为例）" class="headerlink" title="3.4 - 虚拟地址（以页为例）"></a>3.4 - 虚拟地址（以页为例）</h4><p>​在引入了页这个概念后，我们的逻辑（虚拟）地址就可以划分为以下的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址 = 逻辑地址剩余位数 + 页占用的位数</span><br><span class="line"></span><br><span class="line">同时，我们进一步将名称规范一下，逻辑地址剩余位数表示的其实就是对页进行编址，所以称之为页号，表示是第几个页；</span><br><span class="line">也占用的位数其实就是一个页中的第几个字节（因为毕竟总的来说是按照字节编址的），所以可以成为块内偏移；那么我们可以进一步写为:</span><br><span class="line"></span><br><span class="line">逻辑地址 = 页号 + 块内偏移地址</span><br></pre></td></tr></table></figure><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">依旧是上述的情景：</span><br><span class="line">逻辑地址32bit，物理地址24bit，页的大小为1KB</span><br><span class="line">逻辑地址 = 22bit页号 + 10bit页内偏移地址</span><br><span class="line">按照这个逻辑，我们需要记录22bit也就是4M个页的映射记录在页表中，也就是页表的大小为：</span><br><span class="line">4M * （22 +14）bit = 4M * 36bit = 18MB</span><br><span class="line">这是个不小的数字，同时伴随着地址空间的增大，这个数字还会增大，如果使用单级页表需要耗费巨大的连续空间，os对于这种空间的管理需要一定的消耗，而且考虑到并不是所有页都会被使用，所以还会造成大量的空间浪费。</span><br><span class="line">因此引入了多级页表的机制用于减少损耗，提高效率。假设现在使用的是两级页表，那么逻辑地址就可变成：</span><br><span class="line">逻辑地址 = 11bit一级页号 + 11bit二级页号 + 10bit块内（页内）偏移</span><br></pre></td></tr></table></figure><p>​ok，上文提到页表是存储在内存中的，同时我们的页号需要在页表中进行查找，那么我们怎么找到页表呢？</p><p>答案是–<strong>页表始址寄存器</strong></p><p>​页表始址寄存器会记录页表在内存中的起始地址，从而找到页表。页表始址寄存器中的值需要程序上cpu处理初始化上下文环境由进程PCB中获得初始化寄存器中的值。</p><p>​所以我们具体查找流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step4： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step5： 根据物理页框号找到内存中对应的页</span><br><span class="line">step6： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多级页表（二级为例）</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据一级页号和页表始址寄存器中页表起始地址去匹配获得二级页表地址</span><br><span class="line">step4： 根据二级页号在二级页表中匹配真正记录页号到页框号映射的页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：页表中并不需要逐个比对，由于顺序一致，所以</span></span><br><span class="line">页表项地址 = 页表基址 + 页表项大小 × 页号</span><br></pre></td></tr></table></figure><p>​ok，那现在我们可以从上述流程发现（单级页表为例），我们地址转换一共进行了两次访存（访问内存）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次：去内存查找页表获得物理地址</span><br><span class="line">第二次：去内存获取数据</span><br></pre></td></tr></table></figure><p>​同时我们知道，cpu和内存的效率差距很大，所以每一次访存都是一次很大的损耗，那么有没有办法能够提高效率呢？</p><p>​答案肯定是有的，现在计算机系统集成了一套机制–TLB机制，也称之为快表，相对应的就把内存中的页表称之为慢表。</p><h4 id="3-5-局部性原理"><a href="#3-5-局部性原理" class="headerlink" title="3.5 - 局部性原理"></a>3.5 - 局部性原理</h4><p>​谈论快表之前，谈论一下在计算机设计中广泛用到（包括下文的cache系统）的局部性原理；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">时间局部性（Temporal Locality）:</span><br><span class="line"></span><br><span class="line">时间局部性指的是程序在某一时刻访问了某个存储位置后，短时间内可能会再次访问该位置。例如，循环中的变量或频繁使用的子程序都有很高的时间局部性。</span><br><span class="line">例子: 在一个循环中，多次访问相同的变量或数组元素。每次循环迭代时，程序都会访问同一个存储位置。</span><br><span class="line"></span><br><span class="line">空间局部性（Spatial Locality）:</span><br><span class="line"></span><br><span class="line">空间局部性指的是程序在访问某个存储位置时，它附近的存储位置在不久的将来也可能会被访问。这意味着，如果一个存储位置被访问了，存储器中相邻的位置很可能也会被访问。</span><br><span class="line">例子: 在访问数组中的一个元素后，程序很可能会访问相邻的元素。</span><br></pre></td></tr></table></figure><h4 id="3-6-快表（TLB）"><a href="#3-6-快表（TLB）" class="headerlink" title="3.6 - 快表（TLB）"></a>3.6 - 快表（TLB）</h4><p>​快表其实本质上是一个页表的缓存，采用的是相联存储器（硬件），集成在CPU中，速度很快。映入快表后，查找流程就转变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号查找快表，若查找到对应物理页框号直接跳转step5</span><br><span class="line">step4： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br></pre></td></tr></table></figure><h4 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 - 小结"></a>3.7 - 小结</h4><p>​程序编译为可执行程序(二进制文件—ELF文件)；</p><p>​CPU调度进程上处理机运行，同时从PCB中获取信息初始化上下文（包括页表始址寄存器等);</p><p>​取指执行阶段，访存获取指令；</p><p>​查找快表；</p><p>​查找页表；</p><p>​访问内存；</p><p><strong>注意：</strong>这其中还包括查找不命中的情况，并非如此简单顺利，后续有时间再补充！</p><p>​至此，这一部分就完结了！</p><img src="/2024/08/14/computerMem/08/14/computerMem/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" class title="逻辑地址映射关系"><h2 id="四、cache缓存"><a href="#四、cache缓存" class="headerlink" title="四、cache缓存"></a>四、cache缓存</h2><h3 id="1-引言-1"><a href="#1-引言-1" class="headerlink" title="1 - 引言"></a>1 - 引言</h3><p>​我们说物理内存是采用DRAM（动态随机存储器）构成，与CPU之间仍有效率差距，为了提高效率，同时践行局部性原理，引入内存的缓存机制-cache机制。</p><p>​cache采用SRAM（静态随机存储器）构成，比DRAM更快（同时也更贵）。</p><p>​cache作为内存的缓存，会保存部分内存的数据为了保证更快的访问，那么既然是保存部分数据，自然就涉及到以下的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 数据以什么形式保存在cache中</span><br><span class="line">2. 数据调入的方法</span><br><span class="line">3. 如何保证cache和主存数据的一致性</span><br><span class="line">4. 效率问题</span><br></pre></td></tr></table></figure><p>​下面将会对这些问题一一解答。</p><p>​同时上述的虚拟内存、逻辑地址体系完成了逻辑地址到物理地址的转换，现在我们终于拥有了物理地址，开始访问存储器……</p><h3 id="2-数据以什么形式保存在cache中"><a href="#2-数据以什么形式保存在cache中" class="headerlink" title="2 - 数据以什么形式保存在cache中"></a>2 - 数据以什么形式保存在cache中</h3><p>​既然作为内存的副本（缓存），那首先必要的就肯定是<strong>内存中的数据</strong>。</p><p>​那是不是只存储数据就ok了呢，我们从前往后推理一下即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设现在cache中只有内存中的数据：</span><br><span class="line">CPU现在访问的地址为0xfffff1，同时我们假设主存中该地址对应的数据已经把副本放在了cache中，请问CPU去缓存中该如何找到想要的数据呢？</span><br><span class="line">你也许懂了，哦~原来我访问存储器一直都是按照内存地址访问的，现在访问cache并没有对应的物理地址，所以我们得重新加上物理地址，但是cache既然只保存一部分内存中的数据，我难道得重新给cache进行编址吗？</span><br></pre></td></tr></table></figure><p>​显然，上述的推理是合理的。</p><p>​但是，没有必要！因为我们cache是SRAM存储单元构建，该单元的存储速度很快并且存储的数据量也没有内存中那么多，所以没有必要将访问内存的地址线访问存储空间不大的cache，同时减少了资源的浪费。</p><p>​cache采用的是另一套匹配逻辑 — <strong>标签</strong>。</p><p>​同上述虚拟地址与物理地址之间映射的逻辑，我们cache与主存之间的数据交换仍然采用的是一堆字节之间的交换，在主存中我们称为数据块，在cache中我们称为cache行。</p><p>​我们将一个主存块挪到cache行中，需要对这个cache行进行标记，表示对应的是哪一个主存块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">采用逻辑地址访问cache，由于cache行保存的是主存块的副本，所以caache行内的地址等于主存块中的地址。剩下的就是保存主存块到cache行中的映射关系</span><br><span class="line">直接映射：</span><br><span class="line">全相联映射：</span><br><span class="line">组相联映射：</span><br></pre></td></tr></table></figure><h3 id="3-数据调入的方法"><a href="#3-数据调入的方法" class="headerlink" title="3 - 数据调入的方法"></a>3 - 数据调入的方法</h3><h3 id="4-如何保证cache和主存数据的一致性"><a href="#4-如何保证cache和主存数据的一致性" class="headerlink" title="4 - 如何保证cache和主存数据的一致性"></a>4 - 如何保证cache和主存数据的一致性</h3><h3 id="5-效率问题"><a href="#5-效率问题" class="headerlink" title="5 - 效率问题"></a>5 - 效率问题</h3><h2 id="五、磁盘"><a href="#五、磁盘" class="headerlink" title="五、磁盘"></a>五、磁盘</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
