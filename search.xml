<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>存储系统杂谈</title>
      <link href="/2024/08/14/computerMem/"/>
      <url>/2024/08/14/computerMem/</url>
      
        <content type="html"><![CDATA[<h3 id="一、存储系统总览"><a href="#一、存储系统总览" class="headerlink" title="一、存储系统总览"></a>一、存储系统总览</h3><img src="/2024/08/14/computerMem/computer_memflow.png" class title="存储系统流程图"><h3 id="二、内存"><a href="#二、内存" class="headerlink" title="二、内存"></a>二、内存</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 - 概念"></a>1 - 概念</h4><p>​内存（主存）为计算机进行活动过程中用来存储活动数据的空间，比如计算的数据，执行的指令等</p><h4 id="2-内存构成"><a href="#2-内存构成" class="headerlink" title="2 - 内存构成"></a>2 - 内存构成</h4><p>​内存一般由DRAM芯片构成，DRAM芯片利用栅极电容存储信息，所以本质上存储的是电信号，同时栅极电容具有电容的特性，所以DRAM也存在刷新机制用于维护电信号</p><h4 id="3-内存地址"><a href="#3-内存地址" class="headerlink" title="3 - 内存地址"></a>3 - 内存地址</h4><p>​由上可知，内存存储的是电信号，本质上就是正负信号（0&#x2F;1），对应的就是bit位。在计算机系统中，通常使用字节作为单位用来存储8bit（1B &#x3D; 8b）的数据，当我们对每个字节进行编址就得到了整个内存的地址大小。内存地址也即<strong>物理地址</strong>，好比房间和房间号。</p><p>​研究一个问题：假设现在只有一个4GB的内存条，也就是物理内存只能访问到0x0000 ~0xFFFF地址大小，但是如果我的程序很大，比如占用了8个G（模型渲染、机器学习等），但是物理空间只有4GB大小，也就是说我8G的空间，只有4G的门牌号，剩余4G的空间系统里都查不到，这肯定是不合适的，但是我们可以很容易想到一个方法 — 拓展内存大小：</p><p>​我们给我们的主机加上内存条，拓展到8G大小这样不就行了吗？</p><p>​但是有两个缺点：1、贵</p><p>​       2、缓兵之计，要是下一次10G怎么办？</p><p>​有的人又会问，硬盘不贵，同等空间硬盘便宜多了，但是硬盘便宜的代价就是硬盘很慢，所以cpu不会直接同硬盘进行数据交互，cpu宝贵的资源超快的速度不可能每次都等待硬盘进行数据传输，所以我们需要的是一个机制—一个从根本上解决程序地址和物理地址不匹配的机制，那既然程序地址无法同物理地址一一对应，那么我们就可以将耦合解开来，采用别的方式完成程序地址到物理地址的转换，此处转换也即映射，此处程序地址就是我们要谈论的<strong>虚拟地址</strong>。</p><h3 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h3><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1 - 引言"></a>1 - 引言</h4><p>​我们知道，程序员写代码的时候不需要关心物理地址，访问都是通过指针或者索引或者其他形式去访问，既然底层是通过地址去获取存储单元中的数据，那么这一环节是如何转换的呢？</p><p>​以c为例，我们c代码是高级语言，代码执行过程可以有以下的执行过程：</p><img src="/2024/08/14/computerMem/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" class title="程序执行过程"><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span>  <span class="comment">// 预处理阶段处理</span></span></span><br><span class="line"></span><br><span class="line">代码段  <span class="comment">// 编译 -》 汇编 -》 链接 形成基于整个程序空间的逻辑地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ok，现在我们经过了预处理、编译、汇编、链接从而形成了可执行程序，并且整个可执行程序中的数据或者指令也都被我们进行了编址，也就是拥有了基于程序这个空间的地址，那么为什么要进行装入操作呢？直接将可执行程序上CPU运行不就完事了吗？</p><p>​其实，在以前的单道处理系统中是这样的，但是考虑效率现在的多道批处理系统中并非如此，现在的cpu是属于并发（甚至并行）执行多个程序，也就是说多个程序可能都要存储在内存中，那么小程序还行，如果是大程序怎么在有限的内存中进行操作呢？</p><h4 id="2-虚拟地址"><a href="#2-虚拟地址" class="headerlink" title="2 - 虚拟地址"></a>2 - 虚拟地址</h4><p>​上文说到我们需要采用一种机制，解决物理地址有限的问题，我们称之为虚拟地址（逻辑地址）。物理地址受限于物理引脚的个数，物理引脚的个数确定了物理上能访问的空间大小，而虚拟地址则受限于os系统的架构，例如32位x86架构能够访问的空间大小和64位的x64架构能访问的空间大小则完全不同。</p><p>​以32位x86架构的系统为例，我们虚拟地址以32bit进行编制，那么我们能够访问的空间的大小就是0x00000000 ~0xFFFFFFFF地址范围，我们说为什么受限呢？可以想想，我们现在写好了程序，编译、汇编、链接这些操作都是在哪里进行处理的？ 那必须是os中处理，所以我们被人家改造成了人家的位数，合情合理。</p><p>​ok，现在我们的访问地址变大了，在程序的角度能访问的所有的房间都有门牌号了，但是实际的存储范围其实就那么大，我们上文中提到的解决方式是将虚拟地址与逻辑地址之间一一对应的关系改造为虚拟地址到物理地址之间映射的关系从而达到扩大程序地址空间的目的，那么接下来详细谈谈这个映射机制，从<strong>虚拟内存</strong>开始说起。</p><h4 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3 - 虚拟内存"></a>3 - 虚拟内存</h4><p>​我们说，物理地址空间能访问的空间大小称之为物理内存。那么逻辑地址（虚拟地址）能访问的空间大小则称之为虚拟内存。</p><p>​接下来我们考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们之前谈到数据是以二进制存储在内存中，也就是数据是bit位；同时我们谈到内存中对数据编址是通过字节的形式，也就是B字节；</span><br><span class="line">​请问：我们程序运行过程中从内存中获取数据是以bit还是B为单位获取？</span><br><span class="line">​答案：我们地址是按照B为单位进行编址，自然我们也是以B位单位获取数据</span><br></pre></td></tr></table></figure><p>​再考虑一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设现在有以下的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：我们需要将32bit的空间大小映射到24bit空间中，应该怎么做？</span><br><span class="line">​答案：使用一个表，记录下来逻辑地址到物理地址之间的对应关系，拿到逻辑地址的时候查表获取对应的物理地址从而获取对应的数据。</span><br></pre></td></tr></table></figure><h4 id="3-1-页表"><a href="#3-1-页表" class="headerlink" title="3.1 - 页表"></a>3.1 - 页表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，页表存放在内存中。</p><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">还是以上的情景：</span><br><span class="line">逻辑地址空间32bit，物理地址空间24bit；</span><br><span class="line">​请问：现在有一个int类型的数据，请问怎么访问获取这个int类型的数据呢（不考虑大端小端等，只说明大致过程）？</span><br><span class="line">​答案：int类型的数据占用4个字节，也就是要获取连续的4个地址中保存的bit数据，所以我们需要根据将连续的4个逻辑地址通过查找页表来获取对应4个地址的物理地址，从而在物理内存中获取真实的物理数据。</span><br><span class="line"></span><br><span class="line">我们可以发现，再此过程中进行了4次地址转换，获得了4个物理地址，从而获取到了对应的4个B的数据。但是这个过程中存在一个问题，就是页表中也存在4条逻辑地址到物理地址的映射记录，ok，可能4条映射表现出来的问题不够明显，现在考虑我们想要获取如果是1MB的数据，那么映射记录就变成了1M个；如果是1GB数据，那么映射记录就变成了1G个；同时可以计算：</span><br><span class="line">逻辑地址32bit=4B，物理地址24bit=3B；</span><br><span class="line">那么</span><br><span class="line">        1M个记录 = 1M*7B = 7MB；</span><br><span class="line">        1G个记录 = 1G*7B = 7GB；</span><br><span class="line">        可以看出页表占用的内存大小是相当大的。</span><br><span class="line">所以我们需要规避这种空间损耗，那么就必须增大映射的单位大小，换句话说就是将原来以B为单位映射改为以一堆B为单位进行映射，所以页表是以页为单位进行映射的。</span><br><span class="line"></span><br><span class="line">现在我们重新以页的方式进行映射，假设页的大小为1KB，那么此时1MB个数据就缩减为了1K个记录！</span><br></pre></td></tr></table></figure><h4 id="3-2-段表"><a href="#3-2-段表" class="headerlink" title="3.2 - 段表"></a>3.2 - 段表</h4><p>​用于记录逻辑地址到物理地址之间的映射关系，段表存放在内存中。</p><p>​同上，我们还存在一种映射方式是以段为单位进行映射，也就是表中存储的是段的逻辑地址到物理地址之间的映射关系，我们将在下一小节中说明这些差别。</p><h4 id="3-3-页、段、页框"><a href="#3-3-页、段、页框" class="headerlink" title="3.3 - 页、段、页框"></a>3.3 - 页、段、页框</h4><p>​上文分析，为了避免不必要的浪费，我们引入了<strong>页</strong>这个概念，用来将一个B之间的映射转换为一堆B之间的映射；</p><p>​那么<strong>段</strong>存在的意义就是将一堆B之间的映射进一步提升为一个模块之间的映射。</p><p>​例如，现在有两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​那么在os层面，这两个模块照样会经过编译、汇编、链接成为二进制机器语言，那么为了保证函数的完整性，我们提出将func1作为一个段，将func2作为一个段。但是我们知道函数编译出来的产物通常是指令，而不是每个函数的指令长度都是一样的，也就是段的长度受实际代码复杂度等因素影响，所以在段表中我们是需要记录段的长度。</p><p>​在虚拟内存层面我们交换的单位称之为<strong>页</strong>或者<strong>段</strong>，那么物理内存层面我们与之对应的单位也有名字，成为<strong>页框</strong>。</p><h4 id="3-4-虚拟地址（以页为例）"><a href="#3-4-虚拟地址（以页为例）" class="headerlink" title="3.4 - 虚拟地址（以页为例）"></a>3.4 - 虚拟地址（以页为例）</h4><p>​在引入了页这个概念后，我们的逻辑（虚拟）地址就可以划分为以下的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址 = 逻辑地址剩余位数 + 页占用的位数</span><br><span class="line"></span><br><span class="line">同时，我们进一步将名称规范一下，逻辑地址剩余位数表示的其实就是对页进行编址，所以称之为页号，表示是第几个页；</span><br><span class="line">也占用的位数其实就是一个页中的第几个字节（因为毕竟总的来说是按照字节编址的），所以可以成为块内偏移；那么我们可以进一步写为:</span><br><span class="line"></span><br><span class="line">逻辑地址 = 页号 + 块内偏移地址</span><br></pre></td></tr></table></figure><p>​思考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">依旧是上述的情景：</span><br><span class="line">逻辑地址32bit，物理地址24bit，页的大小为1KB</span><br><span class="line">逻辑地址 = 22bit页号 + 10bit页内偏移地址</span><br><span class="line">按照这个逻辑，我们需要记录22bit也就是4M个页的映射记录在页表中，也就是页表的大小为：</span><br><span class="line">4M * （22 +14）bit = 4M * 36bit = 18MB</span><br><span class="line">这是个不小的数字，同时伴随着地址空间的增大，这个数字还会增大，如果使用单级页表需要耗费巨大的连续空间，os对于这种空间的管理需要一定的消耗，而且考虑到并不是所有页都会被使用，所以还会造成大量的空间浪费。</span><br><span class="line">因此引入了多级页表的机制用于减少损耗，提高效率。假设现在使用的是两级页表，那么逻辑地址就可变成：</span><br><span class="line">逻辑地址 = 11bit一级页号 + 11bit二级页号 + 10bit块内（页内）偏移</span><br></pre></td></tr></table></figure><p>​ok，上文提到页表是存储在内存中的，同时我们的页号需要在页表中进行查找，那么我们怎么找到页表呢？</p><p>答案是–<strong>页表始址寄存器</strong></p><p>​页表始址寄存器会记录页表在内存中的起始地址，从而找到页表。页表始址寄存器中的值需要程序上cpu处理初始化上下文环境由进程PCB中获得初始化寄存器中的值。</p><p>​所以我们具体查找流程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单级页表</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据页号和页表始址寄存器中页表起始地址去内存查找页表</span><br><span class="line">step4： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step5： 根据物理页框号找到内存中对应的页</span><br><span class="line">step6： 根据页内偏移地址找到页中指定位置的字节</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多级页表（二级为例）</span></span><br><span class="line">step1： 获得逻辑地址</span><br><span class="line">step2： 根据逻辑地址获得页号</span><br><span class="line">step3： 根据一级页号和页表始址寄存器中页表起始地址去匹配获得二级页表地址</span><br><span class="line">step4： 根据二级页号在二级页表中匹配真正记录页号到页框号映射的页表</span><br><span class="line">step5： 根据页表中的记录获取对应的物理页框号</span><br><span class="line">step6： 根据物理页框号找到内存中对应的页</span><br><span class="line">step7： 根据页内偏移地址找到页中指定位置的字节</span><br></pre></td></tr></table></figure><p>​ok，那现在我们可以从上述流程发现（单级页表为例），我们地址转换一共进行了两次访存（访问内存）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次：去内存查找页表获得物理地址</span><br><span class="line">第二次：去内存获取数据</span><br></pre></td></tr></table></figure><p>​同时我们知道，cpu和内存的效率差距很大，所以每一次访存都是一次很大的损耗，那么有没有办法能够提高效率呢？</p><p>​答案肯定是有的，现在计算机系统集成了一套机制–TLB机制，也称之为快表，相对应的就把内存中的页表称之为慢表。</p><h4 id="3-5-快表（TLB）"><a href="#3-5-快表（TLB）" class="headerlink" title="3.5 - 快表（TLB）"></a>3.5 - 快表（TLB）</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/13/hello-world/"/>
      <url>/2024/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
